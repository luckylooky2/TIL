<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="root" data-reactroot="">
      <div>hello</div>
      <ul>
        <li>apple</li>
        <li>banana</li>
        <li>peach</li>
      </ul>
    </div>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom-server.browser.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" src="hydrate.js"></script>
    <script type="text/babel">
      // 서버사이드 렌더링된 root
      const rootElement = document.querySelector("#root");
      // React는 root와 동일한 컴포넌트를 기대한다.
      ReactDOM.hydrate(<App />, rootElement);

      // 첫 번째 인자로 아무것도 필요없을 줄 알았다.
      // - 이미 렌더링이 되어 있는데, 굳이 필요한가?
      // - 상태 값과 이벤트를 추가해야 하기 때문에 필요하다.

      // 첫 번째 인자로 컴포넌트를 넣는 이유는?
      // - 이 작업이 React의 상태와 이벤트 핸들러를 복원하는 작업이기 때문이다.
      // - 그래서 클라이언트에서 동일한 React 컴포넌트를 다시 전달해 hydrate을 사용하면 이벤트 핸들러와 React의 내부 상태를 연결하여 상호작용이 가능해진다.
      // - 클라이언트에서 hydrate로 동일한 컴포넌트를 연결해야 이벤트와 상태 관리가 추가되어 React 앱이 정상적으로 작동하게 된다.
    </script>
  </body>
</html>

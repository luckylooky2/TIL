## 1.1 자바스크립트의 동등 비교

- 중요한 이유
  - 1. 렌더링이 발생하는 직접적인 이유: props의 동등 (얕은) 비교에 따른 결과
  - 2. 리액트 내에서 다양한 쓰임
    - (1) 가상 DOM과 실제 DOM의 비교
    - (2) 컴포넌트를 렌더링할지를 판단하는 방법
    - (3) 변수나 함수의 메모이제이션
- 정확한 동등 비교를 위해서는 데이터 타입에 대해서 제대로 알아야 한다.

### 데이터 타입

- 원시 타입: `boolean`, `null`, `undefined`, `number`, `string`. `symbol`, `bigint`
  - 메서드를 갖지 않는다.
- 객체 타입: `object`
  - 메서드를 가진다.

```js
typeof true; // boolean
typeof 1; // number
typeof "hello"; // string
typeof 1n; // bigint
typeof Symbol(); // symbol
typeof undefined; // undefined
// 초창기 버그
typeof null; // object
```

### falsy, truthy

- 각각의 데이터가 조건문 내부에서 취급되는 값이다.
- falsy 값
  - `false`(boolean)
  - `0, -0, NaN`(number)
  - ` '', "", `` `(string)
  - `0n, 0x0n`(bigint)
  - `null`(null)
  - `undefined`(undefined)
- truthy 값
  - falsy 값 이외의 모든 값에 해당한다.
  - cf> `[], {}`는 truthy 값에 해당한다.
- `Boolean()` 혹은 `!!`를 통해서도 확인할 수 있다.

### number, bigint

- 부동소수점 방식을 사용하여 수를 표현한다.
- number는 `-(2^53 - 1)` ~ `2^53 - 1` 사이에 정수는 정확하게 저장할 수 있다.
- 그 외의 정수는 정확하게 표현할 수 없기 때문에 bigint를 사용한다.
- int 범위에서 해결 가능하다면 number, long long 범위까지 포함한다면 bigint를 사용하자.

```js
Number.MAX_SAFE_INTEGER; // 9007199254740991
Number.MAX_VALUE; // 1.7976931348623157e+308
// 2진수, 8진수, 16진수 표현 방식도 가능하다.
0b10 == 2; // true

// bigint는 더 큰 정수 범위를 오차없이 표현할 수 있다.
Number.MAX_SAFE_INTEGER === Number.MAX_SAFE_INTEGER + 1; // false
// 더 이상 다룰 수 없기 때문이다.
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true
BigInt(Number.MAX_SAFE_INTEGER) + 1n === BigInt(Number.MAX_SAFE_INTEGER) + 2n; // false

// bigint와 number은 혼합하여 사용할 수 없다.
BigInt(Number.MAX_SAFE_INTEGER) + 1; // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions

// 값을 비교할 때는 동일하게 나오지만, 타입까지 비교할 때는 다르다.
1 == 1n; // true
1 === BigInt(1); // false
```

### string

```js
const name = "Tom";

// 백틱은 줄바꿈이 가능하고 내부에 표현식을 넣을 수 있다.
const str1 = `
안녕하세요. ${name}
`; // '\n안녕하세요. Tom\n`

// const str2 = "
// 안녕하세요.
// "; // Uncaught SyntaxError: Invalid or unexpected token

// 문자열은 한 번 생성되면 변경 불가능하다.
const foo = "bar";
foo[0] = "a";
console.log(foo); // bar

const foo2 = ["b", "a", "r"];
foo2[0] = "a";
console.log(foo2); // ["a", "a", "r"]
```

### symbol

- ES6에서 새롭게 추가된 타입이다.
- **중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다.**
- 심볼을 생성하려면 반드시 Symbol()을 사용해야 한다.

```js
const [s1, s2] = [Symbol("key"), Symbol("key")];
// 넘겨주는 key가 같더라도 둘의 심볼 값은 다르다.
s1 === s2; // false
s1 == s2; // false
s1 === s1; // true

// 동일한 값을 사용하기 위해서는 Symbol.for를 활용한다.
// 여러 파일에 걸쳐, 각자 별도의 전역 스코프를 갖는 경우에도 공유할 수 있는 심볼을 사용하려면 for, keyFor을 사용해야 한다.
// 이 방법은 key를 공유한다는 점에서 위의 방식과 다르다.
Symbol.for("hello") === Symbol.for("hello"); // true
```

### 값을 저장하는 방식의 차이

```js
// 원시 타입
let str1 = "hello";
// 복사할 때, 변수에 값으로 저장된다.
let str2 = str1;
str1 === str2; // true
str2 = "hi";
str1 === str2; // false

// 객체 타입
const obj1 = { num: 42 };
// 복사할 때, 변수에 참조값으로 저장된다.
const obj2 = obj1;
obj1 === obj2; // true
obj1.num = 43;
obj1 === obj2; // true
```

### 비교 방법

- 1. `==`: 양쪽이 같은 타입이 아니라면, 비교할 수 있도록 강제로 형변환 후 비교한다.
- 2. `===`: 양 쪽의 타입까지 고려한다.
- 3. `Object.is()`
  - `===` 비교 방법이 가지는 한계(몇 가지 케이스)를 극복하기 위해 ES6에서 추가하였다.
  - **리액트에서 사용하는 동등 비교**

```js
5 == "5"; // true
5 === "5"; // false

-0 === +0; // true
Object.is(-0, +0); // false

// 객체 비교는 차이가 없다.
{} == {}; // false
{} === {}; //false
Object.is({}, {}); // false
```

- 리액트에서는 `objectIs`를 기반으로 한 `shallowEqual` 함수를 만들어서 사용한다.
- 의존성 비교 등 리액트에서 동등 비교가 필요한 다양한 곳에 사용된다.

```js
function objectIs(x, y) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || // 0과 -0을 구분하기 위해
    (x !== x && y !== y) // NaN === NaN을 위해
  );
}
// 1 / 0 = Infinity, 1 / -0 = -Infinity
// NaN은 항상 자기 자신과 같지 않다고 평가
```

```js
function shallowEqual(objA, objB) {
  // 두 객체의 참조가 같으면 무조건 같다고 판단
  // - 조건 1: 두 객체의 가장 상위 참조는 달라야 한다.
  // objectIs만 사용한다면 참조만 달라졌고 내용은 똑같은 경우에도 불필요한 렌더링을 야기한다
  if (objectIs(objA, objB)) {
    return true;
  }

  // 아래부터는 null이 아닌 Object 타입이어야 한다
  if (
    typeof objA !== "object" ||
    objA === null ||
    typeof objB !== "object" ||
    objB === null
  ) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // 두 객체의 참조가 다르더라도, 내부 프로퍼티들이 모두 같은 참조(또는 값)를 가지고 있으면 동일하다고 판단
  // - 조건 2: 내부 프로퍼티(또는 원소)의 모든 값(또는 참조) 중 하나라도 달라야 한다.
  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !objectIs(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}

const a = { hello: "123" };
const b = { hello: "123" };
console.log(shallowEqual(a, b)); // true
console.log(shallowEqual(a, { ...a, hi: "123" })); // false
console.log(shallowEqual(a, { ...a })); // true

const c = [1, 2, 3];
const d = [{}, {}, {}];
console.log(shallowEqual(c, [...c])); // true
console.log(shallowEqual(c, [...c, 4])); // false
console.log(shallowEqual(d, [...d])); // true

const e = [...d];
e[0] = {};
console.log(shallowEqual(d, e)); // false

console.log(shallowEqual(null, null)); // true
console.log(shallowEqual(1, 1)); // true

// 얕은 비교란, 첫 번째 깊이에 존재하는 *값*만 비교한다.
console.log(shallowEqual({ hello: "world" }, { hello: "world" })); // true
// 2 depth 까지 모두 같더라도, *참조가 다르기 때문에* false를 반환한다.
console.log(
  shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } })
); // false
```

- React.memo는 shallowEqual(이전 props, 바뀐 props)의 결과에 따라 렌더링 여부를 결정한다.
- props에 메모이제이션하지 않은 객체를 넘기는 경우, memo가 제대로 동작하지 않을 수 있다.
- 일반적인 케이스에서는 props의 프로퍼티를 일차적으로만 비교하는 것이 성능적으로 유리할 것이다.
- 재귀를 사용해 완벽히 같은지를 확인하는 것은 성능 하락을 가져올 수 있다.

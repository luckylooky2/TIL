# 9.2 깃허브 100% 활용하기

- 코드 저장소, CI/CD 자동화, 보안 이슈 점검, 프로젝트 관리 등 다양한 기능을 제공한다.

## 깃허브 액션으로 CI 환경 구축하기

- CI: 코드의 변화를 모으고 관리하는 코드 중앙 저장소에서, 여러 기여자가 기여한 코드를 지속적으로 빌드하고 테스트해 코드의 정합성을 확인하는 과정이다.
- 코드에 변화가 있을 때마다 전체 소프트웨어의 정합성을 확인하기 위해 자동으로 테스트, 빌드, 정적 분석, 보안 취약점 분석 등을 수행한다.
- Jenkins: 서버 구축 등 설치 및 유지보수가 번거롭다.
- 깃허브 액션: 깃허브를 기반으로 깃허브에서 발생하는 다양한 이벤트를 트리거 삼아 다양한 작업(푸시하면 빌드, PR이 열리면 빌드 및 테스트 등)을 하기 위한 목적이다.
- 프론트엔드는 대부분 저장소에 있는 코드만으로도 테스트, 빌드, 정적 분석 등 CI에 필요한 작업을 수행할 수 있다.

### 깃허브 액션 기본 개념

- runner: 깃허브 액션을 실행하는 서버
- action: 하나의 작업 단위
- event: 액션이 실행되는 트리거(pull_request, push, issue 등)
- jobs: step의 모음. 병렬로 실행
- steps: 하나의 작업 단위. 순차로 실행
- steps(순차) => job(병렬) => action => runner

### 깃허브 액션 작성하기

- .github/workflows 디렉터리에 yaml, yml 파일로 작성한다.
- Jenkins보다 쉽게 CI를 구축할 수 있다.
- action/github-script를 사용해 깃허브 API를 직접 호출하여 PR에 댓글을 달거나, 일정 시간마다 작업을 수행하거나, 저장소 내부에 이미지가 추가될 때마다 이미지를 최적화할 수 있다.
- settings-code and automation-branches에서 브랜치 보호 규칙을 적용할 수 있다. 아래와 같은 조건이 달성된 브랜치만 머지할 수 있도록 하여 코드의 정합성을 유지할 수 있다.
  - 머지하기 전 상태 체크 필수
  - 머지할 브랜치가 최신 내용인지 확인
  - 머지할 때 PR이 작성되었는지 확인

```yaml
name: CI
run-name: CI
# main 브랜치에 푸시하거나 PR을 열 때만 실행
on:
  push:
	branches:
	  - main
  pull_request:
	branches:
	  - main

jobs:
  build:
	runs-on: ubuntu-latest # runner
	steps:
	  - name: Checkout
		uses: actions/checkout@v2
	  - name: Setup Node.js
		uses: actions/setup-node@v2
		with:
		  node-version: '14'
	  - name: Install Dependencies
		run: npm install
	  - name: Build
		run: npm run build
	  - name: Test
		run: npm run test
```

### 직접 작성하지 않고 유용한 액션과 깃허브 앱 가져다 쓰기

- actions/checkout: 저장소를 체크아웃
- actions/setup-node: Node.js 설치
- actions/github-script: 깃허브 API 호출
- actions/stale: PR이 오래되면 닫기
- actions/dependency-review-action: package.json 등의 내용이 변경되었을 때, 의존성을 분석해 PR에 댓글을 달아주는 액션
- actions/codeql-action: 코드 취약점 분석
- calibreapp/image-actions: CDN을 사용하지 않고 저장소 내의 이미지를 sharp 패키지를 이용해 jpg, png 등을 거의 무손실로 압축하여 다시 커밋한다. 결과를 PR 댓글로 남긴다.
- lirantal/is-website-vulnerable: 웹사이트를 방문해 웹사이트에 노출되어 있는 라이브러리의 취약점 분석한다. 취약점이 발견되면 action이 실패한다. 주기적으로 실행하되, needs 구문, on.workflow_run 등을 이용하여 배포가 완료된 이후에 실행하도록 한다.
- Lighthouse CI: 웹사이트의 성능 지표를 확인한다. PR에 댓글로 결과를 남긴다. lhci 명령어와 프로젝트에 .lighthouserc.js를 추가해 설정할 수 있다.

## 깃허브 Dependabot으로 보안 취약점 해결하기

- 의존성에 문제가 있다면, 문제를 알려주고 가능하면 해결할 수 있는 PR까지 열어주는 강력한 기능이다.

### package.json의 dependencies 이해하기

#### 유의적 버전

- semantic versioning: major.minor.patch

  - major: 하위 호환성이 깨질 수 있는 변경(16.0.0 -> 17.0.0)
  - minor: 하위 호환성이 유지되는 새로운 기능 추가(16.0.0 -> 16.1.0)
  - patch: 하위 호환성이 유지되는 버그 수정(16.0.0 -> 16.0.1)

- 패키지를 배포하고 나면 이전 버전의 내용은 절대 변경하지 말아야 한다. 변경사항이 있다면 새로운 버전을 배포한다.
- 0.x.x 버전은 초기 개발 단계로, 하위 호환성이 깨질 수 있는 변경이 있을 수 있다.
- 버그 수정이 API 변경을 동반한다면, major 버전을 올려야 한다.

- 16.0.0: 정확히 16.0.0 버전에 의존
- ^16.0.0: minor 버전까지만 업데이트(16.0.0 -> 16.1.0)
- ~16.0.0: patch 버전까지만 업데이트(16.0.0 -> 16.0.1)

- 어디까지나 개발자들 간의 약속이므로, 의존성을 업데이트할 때는 실제로 업데이트된 내용을 확인해야 한다.
- color.js 사건: 1.4.0 -> 1.4.1 patch 버전을 올리는 과정에서 작동이 불가능한 패키지를 배포하여, 1.4.0을 제외한 ^1.4.0, ~1.4.0 등의 버전을 사용하는 프로젝트가 모두 작동이 불가능해졌다.

#### 의존성

- dependencies: 프로덕션 환경에서 필요한 의존성
- devDependencies: 개발 환경에서만 필요한 의존성
- peerDependencies: 의존성을 가진 패키지가 필요로 하는 의존성
- 앞의 두 개를 구분하는 것이 필요한가?
  - 실제 서비스에 배포해야 하는 라이브러리인지를 결정하는 것은 번들러이다.
  - 빌드를 하기 위해서는 typescript가 devDependencies에 있기 때문에 어차피 devDependencies까지 모두 설치해야 한다.
- npm에 업로드할 패키지를 개발한다면 구분하는 것은 매우 중요하다.

### Dependabot으로 취약점 해결하기

#### 취약점 발견하기

- 의존성에 숨어 있는 잠재적인 위협을 깃허브를 통해 확인하고 해결할 수 있다.
- 깃허브의 Security-Dependabot Alerts를에서 확인할 수 있다.
- Critical - High - Moderate - Low 순으로 위험도가 낮아진다.
- 문제가 되는 패키지를 찾았다면, npm ls <패키지명> 으로 어디에 설치되어 있는지 확인해본다. 어떤 패키지가 해당 패키지를 어떤 버전으로 사용하는지 확인해본다.
- 왜 문제가 되는지 파악해본다. 단, 직접적인 영향이 특별히 없을 수도 있다.
- 그 이유는 리액트 팀이 실제 취약점이 있는 패키지를 사용한다 하더라도 실제 개발자에게 미칠 수 있는 영향이 없는 경우에는 취약점을 긴급하게 수정하지 않겠다고 했기 때문이다
- 즉, 취약점이 발생하는 시나리오로 사용하지 않는다면 문제가 없다는 뜻이다.
- 실질적으로 중요하지 않은 취약점을 노출시키는 것은 진짜 취약점을 확인하는데 방해가 된다고 주장한다. (취약점 분석 도구인 npm audit에 대한 비판)

#### 취약점 해결하기

- Dependabot이 열어 준 PR은 이미 해결한 패치가 존재한다는 뜻이다.
- 단, 해결한 패치로 업그레이드한 이후에 문제가 발생할 수도 있기 때문에 자세한 확인이 필요하다.
- 문제가 없다면 PR 머지를 통해 문제를 해결할 수 있다.

- PR로 해결하기 힘든 경우는?
- npm ls <패키지명> 으로 어떤 패키지가 해당 패키지를 어떤 버전으로 사용하는지 확인해본다.
- 가장 쉽게 해결하는 방법은 (문제를 해결했다면) patch 버전을 올리는 것이다.
- 버전을 강제로 올릴 수 있는 방법은 package.json에 overrides를 선언하는 방법이다.

```json
{
  "overrides": {
    "minimatch": {
      "version": "^3.0.5"
    }
  }
}
```

- 내부 의존성에서 사용하고 있는 모든 minimatch의 벚전을 ^3.0.5으로 덮어쓰라는 의미이다.

#### 정리

- 의존성 관련 이슈를 방지하는 가장 좋은 방법은 의존성을 최소한으로 유지하는 것이다.
- 가능한 한 내재화할 수 있는 모듈은 내재화하고, 의존성을 최소한으로 유지하는 것이 좋다.
- 가능한 한 널리 알려져 있고, 많은 사람들이 사용하는 그리고 활발하게 유지보수되는 패키지를 사용해야 한다.
- Dependabot이 경고하는 문제에 대해 책임감을 가지고 계속해서 관심을 가져야 한다.
- Dependabot은 이슈를 찾는 용도로만 사용하고, 해결책을 맹신하지 않는다.

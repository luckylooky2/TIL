 - TCP 연결은 클라이언트 측에서 먼저 요청(connect)을 하고, 서버 측에서 이에 응답(accept)을 하여 연결이 이루어진다. 즉, 서버 측에서 먼저 요청을 하지 않는다.
 - 하지만 TCP 종료는 두 가지 상황이 발생할 수 있다.
	 - 클라이언트 측에서 먼저 close를 호출할 수도 있고,
	 - 서버 측에서 먼저 close를 호출할 수도 있다.
	 - 중요한 것은, 누가 먼저 close를 호출하는냐에 따라서 소켓 상태의 결과가 달라진다.
 - 먼저 close를 호출한 쪽을 active close, 상대방을 passive close라고 말한다.
	 - 클라이언트가 active close가 될 수도 있고, 서버가 active close가 될 수도 있다. 즉, 누가 먼저 close를 호출하는가에 따라 역할이 달라진다.
	 - ![tcp](2024.01/img/1.15/image1.png)
	 - 순서
		 1. active close가 close를 호출하여 먼저 FIN을 보낸다
		 2. FIN을 받은 passive close는 ACK를 보낸다
		 3. active close는 FIN_WAIT 상태로 바뀌고, passive close는 CLOSE_WAIT 상태로 바뀐다
		 4. passive close가 close를 호출하여 FIN을 보낸다
		 5. active close는 TIME_WAIT 상태로 바뀌고, passive close는 LAST_ACK 상태로 바뀐다
		 6. FIN을 받은 active close는 ACK를 보낸다
- TIME_WAIT 상태
	- 소켓이 TIME_WAIT 상태를 유지하는 동안 소켓을 사용할 수 없다
- 클라이언트가 먼저 close를 하는 시나리오
	- 위의 그림에서 볼 수 있듯이, TIME_WAIT 상태는 "클라이언트 측 소켓"에서 발생한다
		- 클라이언트 소켓(e.g. 61321)
	- 웹 서버에서 이를 구현하기 위해서는, 클라이언트 쪽에서 보낸 빈 문자열을 서버 소켓에서 읽고 close를 호출한다
		- 서버 소켓에서 빈 문자열을 읽었다면(read의 리턴값이 0), 클라이언트가 close를 호출한 결과를 받은 것이기 때문에 클라이언트가 먼저 close를 호출하였다고 볼 수 있다.
	- `siege` 명령어를 통해 엄청 많은 TCP 연결을 맺고 요청을 보낼 때, 클라이언트가 먼저 close를 하면 TIME_WAIT 상태가 다음과 같이 클라이언트 측 소켓(613xx)에서 발생하는 것을 확인할 수 있다.
	- 이 때, 클라이언트 측 소켓들은 사용하지 못하는 상태이므로 `siege` 명령어를 통해 connect를 호출하면 EADDRNOTAVAIL 에러 코드와 함께 실패한다.
```shell
$> siege -c10 -t10S http://localhost:8080

$> netstat -p tcp -a -n | grep TIME_WAIT

tcp4       0      0  127.0.0.1.61321        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61324        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61325        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61326        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61328        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61327        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61329        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61331        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61332        127.0.0.1.8080         TIME_WAIT
tcp4       0      0  127.0.0.1.61330        127.0.0.1.8080         TIME_WAIT
```
- 서버가 먼저 close를 하는 시나리오
	- TIME_WAIT 상태는 "서버 측 소켓"에서 발생한다
		- 서버 리슨 소켓(e.g. 8080)
	- 웹 서버에서 이를 구현하기 위해서는 클라이언트에 연결된 소켓에 write를 하고, 바로 close를 호출한다
		- 클라이언트는 소켓 버퍼에 데이터가 있으므로 이를 읽고 close를 호출한다.
		- 전송하는데 그리고 읽는데 시간이 걸리기 때문에, 서버가 close를 먼저 호출한 상황이라고 볼 수 있다.
		- `siege` 명령어를 통해 엄청 많은 TCP 연결을 맺고 요청을 보낼 때, 서버가  먼저 close를 하면 TIME_WAIT 상태가 다음과 같이 서버 측 소켓(8080)에서 발생하는 것을 확인할 수 있다.
		- 클라이언트 측 소켓은 TIME_WAIT 상태가 아니라 완전한 CLOSE(사용할 수 있는) 상태이므로 `siege` 명령어를 통해 새로운 connect를 호출하여도 connect에서 오류가 발생하지는 않는다.
		- 대신에 상대방(서버) 포트는 TIME_WAIT 상태이기 때문에 바로 사용할 수 없고, 사용할 수 있을 때까지 connect는 블록된다.
```shell
$> siege -c10 -t10S http://localhost:8080

$> netstat -p tcp -a -n | grep TIME_WAIT

tcp4       0      0  127.0.0.1.8080         127.0.0.1.56747        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56748        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56750        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56749        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56753        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56751        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56752        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56754        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56755        TIME_WAIT
tcp4       0      0  127.0.0.1.8080         127.0.0.1.56757        TIME_WAIT
```
- 종합하면, 클라이언트 쪽에서 매우 많은 TCP 연결 요청이 발생하여(충분히 그럴 수 있다) 사용할 수 있는 포트가 고갈된다고 할 때 클라이언트 쪽에서 에러가 발생하지 않으려면, 서버 측에서 active close가 되어 먼저 close를 호출해야 한다.
- HTTP 1.0 비지속 연결 때는 당연히 write 이후 서버 측에서 먼저 close를 하면 되었기 때문에 모든 TCP 연결에 대해 바로 해제를 하면 되었다.
- 하지만 HTTP 1.1은 지속 연결이 default이기 때문에, 클라이언트가 active close가 될 가능성이 발생한다.
- 클라이언트가 active close가 되지 않기 위해서 지속 연결 중에 연결을 해제하고 싶은 경우, 요청 헤더에 `Connection: close` 를 함께 보낸다. 이 메시지를 받은 서버는 write를 하고 먼저 close를 호출하는 방식으로 먼저 active close가 된다.
	- 클라이언트에서 먼저 active close가 되어도 아무 문제가 발생하지 않는다면, `Connection: close` 를 굳이 포함할 필요가 없다.
	- `Connection: close` 를 굳이 포함하여 보내는 이유는 문제를 발생시키지 않기 위함이다.
	- 클라이언트가 `Connection: close` 을 보내지 않고 active close가 되는 상황이 발생한다면, 그것은 클라이언트의 책임이다(?)
- 클라이언트가 active close가 되지 않는 상황이 발생하려면, TCP 계층 만으로는 안 되고, 위와 같이 애플리케이션 계층에서의 처리가 필요하다. 

Q. 클라이언트가 active close가 되면 어떤 치명적인 문제가 발생해?

A. 클라이언트가 active close를 하는 것이 반드시 치명적인 문제를 일으키는 것은 아니지만, 특정 상황에서 문제가 발생할 수 있습니다. 이러한 문제는 주로 네트워크 프로토콜 및 연결 관리에 관련된 것입니다.

1. **Half-Open 연결 문제:** 이미 언급한 것처럼, 클라이언트가 active close를 하는 경우 서버는 해당 FIN 메시지를 받아들이고 적절히 응답해야 합니다. 만약 서버가 이를 인지하지 못하거나 처리하지 않으면 Half-Open 연결 상태가 발생할 수 있습니다.
    
2. **데이터 손실:** 클라이언트가 active close를 하면 서버는 클라이언트의 FIN 메시지를 받고 자신의 FIN 메시지를 보내야 합니다. 이 때, 서버가 아직 클라이언트에게 보내야 할 데이터가 있는 경우 해당 데이터가 손실될 수 있습니다.
    
3. **TIME_WAIT 상태 지속 시간:** TCP 연결이 종료된 후 클라이언트는 일정 시간 동안 TIME_WAIT 상태에 머무릅니다. 이는 클라이언트가 마지막 ACK 메시지를 받은 후 일정 시간 동안 해당 연결에 대한 재전송된 패킷이나 중복 패킷을 처리하기 위한 것입니다. Active close를 하는 경우 클라이언트에서는 이 TIME_WAIT 상태를 가지게 되며, 이로 인해 연결 리소스가 일정 시간 동안 소비될 수 있습니다.
    

종종 passive close를 통해 서버 측에서 연결을 종료하는 것이 이러한 문제를 피하는 데 더 효과적일 수 있습니다. 그러나 상황에 따라서는 active close가 필요한 경우도 있을 수 있습니다. 따라서 프로토콜 및 상황에 따라 적절한 연결 종료 방법을 선택하는 것이 중요합니다.

Q. 그럼 TIME_WAIT 상태를 서버 측 소켓이 가져가는 것이 일반적이야?

A. 네, 일반적으로 TIME_WAIT 상태는 서버 측 소켓에서 발생합니다. TIME_WAIT 상태는 TCP 연결이 종료된 후에 해당 연결에 대한 정리 작업을 수행하기 위해 일정 시간동안 대기하는 상태입니다. 이는 클라이언트와 서버 간의 연결을 안전하게 종료하기 위한 메커니즘으로 사용됩니다.

클라이언트가 연결을 종료한 후에도 서버 측에서 TIME_WAIT 상태를 가지는 이유는 다음과 같습니다:

1. **클라이언트의 재전송된 FIN 메시지 처리:** 클라이언트가 FIN 메시지를 보내면, 이 메시지가 중간에 손실되거나 지연될 수 있습니다. 서버가 클라이언트의 FIN 메시지를 정상적으로 받았는지 확인하기 위해 TIME_WAIT 상태에서 대기하며, 만약 FIN 메시지의 중복이나 재전송이 발생한다면 이를 올바르게 처리합니다.
    
2. **클라이언트가 마지막 ACK를 수신할 동안 대기:** 서버는 클라이언트의 FIN에 대한 마지막 ACK를 기다리는 동안 TIME_WAIT 상태에 머무릅니다. 이는 클라이언트가 마지막으로 보낸 ACK가 서버에 도달하고 모든 데이터가 제대로 처리되었음을 확인하기 위한 것입니다.
    

TIME_WAIT 상태의 기간은 일반적으로 2 MSL(Minimum Segment Lifetime)로 설정되며, MSL은 2분을 나타냅니다. 따라서 대부분의 경우 TIME_WAIT 상태는 약 4분 동안 지속됩니다. 이 기간 동안에는 해당 포트를 재사용하지 않고 기다리게 됩니다.

전체적으로, TIME_WAIT 상태는 연결 종료의 정확성과 신뢰성을 보장하기 위한 목적으로 사용되며, 일반적으로 서버 측에서 발생하는 것이기 때문에 서버 리소스를 관리하는 중요한 부분입니다.

https://tech.kakao.com/2016/04/21/closewait-timewait/
https://smjeon.dev/etc/tcp-state/

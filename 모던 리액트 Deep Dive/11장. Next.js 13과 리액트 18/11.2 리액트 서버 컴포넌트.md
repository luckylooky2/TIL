# 11.2 리액트 서버 컴포넌트

- 서버 컴포넌트는 서버 사이드 렌더링과는 완전히 다른 개념이다.
- 어떤 문제를 해결하기 위해서?

## 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 컴포넌트: 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드를 실행한다.
- 클라이언트 사이드 렌더링: 리액트 실행에 필요한 코드를 다운로드 -> 리액트 컴포넌트 트리 생성 -> DOM 렌더링
- 서버 사이드 렌더링: 서버에서 DOM을 생성 -> 클라이언트에서는 DOM에 하이드레이션(상태, 이벤트 핸들러 추가)을 수행

### 지금까지의 구조의 명백한 한계점

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다
  - 원인: 클라이언트에서 라이브러리를 다운로드 및 실행해야 한다.
  - 해결: 서버에서 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물을 클라이언트에 전달하면 어떨까?
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다
  - 원인: Rest API를 통해 백엔드에 접근해야 한다.
  - 해결: 클라이언트에서 직접 백엔드에 접근해 원하는 데이터를 가져오면 어떨까?
- 코드 분할이 불가능하다
  - 원인: 코드를 실행하기 전까지 어떤 lazy 컴포넌트를 렌더링할지 알 수 없어서 이점이 상쇄된다.
  - 해결: 서버에서 코드 분할을 자동으로 수행해준다면 어떨까?
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다
  - 원인: 하나의 페이지에서 반복적으로 클라이언트와 서버 간의 요청과 응답이 발생하여 비효율적이다.
  - 해결: 클라이언트에서 연쇄적 요청없이, 서버에서 모두 수행하면 어떨까?
- 추상화에 드는 비용이 증가한다
  - 원인: 리액트 코드와 결과물(HTML) 사이에 추상화 계층이 추가되어 복잡성이 증가하고 런타임에 변환하는 비용이 발생한다.
  - 해결: 서버에서 리액트 코드를 실행하고, 결과물을 클라이언트에 전달하면 어떨까?
- 이렇게 서버 사이드 렌더링의 한계점을 쭉 살펴본다면 모든 문제는 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제라는 것을 알 수 있다.
- 결국 SSR, CSR 모두 이 문제를 해결하기에는 조금씩 아쉬움이 있다.
- 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트이다.

## 서버 컴포넌트란?

- 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.
- 즉, 일부 컴포넌트는 클라이언트에서 일부 컴포넌트는 서버에서 렌더링하는 방법이다.
- GPT) 리액트 서버 컴포넌트는 클라이언트에서 실행될 필요가 없는 일부 컴포넌트를 서버에서 실행할 수 있도록 지원한다.
- 서버 컴포넌트는 서버에서 실행되고, 그 결과로 생성된 HTML과 데이터를 클라이언트에 전달한다. 클라이언트는 이 결과를 바로 렌더링하며, 추가 자바스크립트를 다운로드하지 않는다.

- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. 만약 클라이언트 컴포넌트가 서버 컴포넌트를 불러오게 된다면 브라우저에서는 서버 환경이 존재하지 않으므로 서버 컴포넌트를 실행할 수 없다.

- 서버 컴포넌트
  - 상태를 가질 수 없다: useState, useReducer, 사용자 정의 훅을 사용할 수 없다.
  - 생명주기가 없다: useEffect, useLayoutEffect를 사용할 수 없다.
  - window, document와 같은 클라이언트 전역 객체에 접근할 수 없다.
  - 비동기 함수 컴포넌트로 만들 수 있다.
  - 서버 컴포넌트, 클라이언트 컴포넌트 둘 다 렌더링이 가능하다.
- 클라이언트 컴포넌트
  - 리액트 컴포넌트와 대부분 같다: 상태, 생명주기, 전역 객체에 접근 가능하다.

```tsx
// 서버 컴포넌트를 불러올 수 없다.
import { ServerComponent } from "./ServerComponent";

export default function ClientComponent() {
  return (
    <div>
      <ServerComponent />
    </div>
  );
}
```

```tsx
// 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다
// 클라이언트 컴포넌트는 서버에서 생성된 트리를 받아서 렌더링할 수 있기 때문이다.
export default function ClientComponent({ children }) {
  return <div>{children}</div>;
}

export default function App() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

- 공용 컴포넌트
  - 서버, 클라이언트에서 모두 사용할 수 있다. 둘 다의 제약을 받는 컴포넌트가 된다.
- 리액트는 모든 것을 다 공용 컴포넌트로 판단한다. 즉, 모두 서버에서 실행 가능한 컴포넌트로 분류한다.
- 리액트 서버 컴포넌트는 여러 가지 제약 요소로 인해 번들러나 특정 프레임워크의 도움을 받는 것이 필수적이다. 서버 컴포넌트를 구현하기 위해서 웹팩. Next.js 등과 함께 협업하였다.

### 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링: 서버에서 페이지 전체를 HTML로 렌더링하고 응답으로 클라이언트에게 보내준다. 이후 클라이언트에서 하이드레이션을 거친다.
  - 목적: 초기에 인터랙션은 불가능하지만, HTML을 빠르게 내려주는데 초점이 있다.
  - 여전히 클라이언트에서 자바스크립트 코드를 다운로드, 파싱, 실행하는데 시간이 소요된다.
- 서버 사이드 렌더링과 서버 컴포넌트 동시 채택
  - 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 전달받는다.
  - 클라이언트 컴포넌트와 서버 컴포넌트 모두 빠르게 보여줄 수 있고, 자바스크립트 다운로드의 양도 줄어들 것이다.

### 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 루트에 있는 컴포넌트는 항상 서버 컴포넌트이다. 루트부터 서버 렌더링을 시작한다.
2. 서버는 컴포넌트를 JSON(와이어 포맷)으로 직렬화한다. 서버에서 렌더링할 수 있는 것은 직렬화하여 내보내고, 클라이언트 컴포넌트는 공간을 비워둔다.
3. 브라우저에 JSON을 스트리밍을 통해 전송한다: 사용자는 결과물을 빠르게 볼 수 있다.
4. 브라우저는 JSON을 받아 역직렬화를 수행한다.
5. 브라우저는 클라이언트 컴포넌트는 렌더링하고, 서버 컴포넌트는 그대로 가져와서 컴포넌트 트리를 구성한다.

- 서버 사이드 렌더링처럼 결과가 HTML이 아니라 JSON이다. 이 구조는 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와준다.
- JSON으로 직렬화할 수 없는 데이터(e.g. class, Date)는 서버에서 클라이언트로 넘겨줄 방법이 없다(자바스크립트 고유 객체이기 때문이다).

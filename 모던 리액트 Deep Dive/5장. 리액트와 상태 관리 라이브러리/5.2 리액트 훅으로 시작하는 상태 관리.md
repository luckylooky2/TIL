# 5.2 리액트 훅으로 시작하는 상태 관리

- 훅과 함수 컴포넌트의 패러다임에서 _애플리케이션 내부 상태 관리를 어떤 방식으로 하고 있는지_ 알아보자.

## 가장 기본적인 방법: useState와 useReducer

- useState, useReducer 그리고 이 훅을 활용한 사용자 정의 훅은 모두 **지역 상태 관리**를 위해 만들어졌다.
- 즉, 훅을 사용할 때마다 컴포넌트별로 초기화되므로, 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다.
- 여러 컴포넌트가 동시에 사용할 수 있는 전역 상태로 만들려면 어떻게 해야 하는가?
- **상태값을 부모 컴포넌트로 끌어 올리고 props를 이용하여 공유하는 방법이 있다.**
- 하지만 props 형태로 제공해야 하는 점은 prop drilling이 발생할 수 있는 여지가 있다.

## 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- useState 기반이 아닌 완전히 다른 곳에서 초기화돼서 관리할 수 있지 않을까?

### 1. 상태를 컴포넌트 밖에 선언한다

```tsx
let state = {
  counter: 0,
};

function get() {
  return state;
}

function set(nextState) {
  state = typeof nextState === "function" ? nextState(state) : nextState;
}

function Counter() {
  const state = get();

  function handleClick() {
    // state는 잘 업데이트되고 있는데 화면이 바뀌지 않는다.
    set((prev) => ({ counter: prev.counter + 1 }));
  }

  // 리렌더링이 되고 있지 않기 때문이다: setState를 호출하고 있지 않다.
  return (
    <>
      <h3>{state.counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- 상태는 바뀌는데 화면이 업데이트되지 않는다.

### 2. useState의 인자로 state를 넘겨준다

[](./implementGlobalState/implementGlobalState.js)

- 상태도 바뀌고 화면도 업데이트된다.
- 하지만 이 방법은 상태를 중복해서 관리하므로 비효율적이다.
- 추가로, 상태 업데이트가 이루어지는 컴포넌트의 상태만 업데이트되는 문제가 발생한다.
- 다른 컴포넌트는 상태의 변화에 따른 리렌더링을 발생시킬 무언가가 없기 때문에 렌더링되지 않는다.

- 함수 외부에서 상태를 공유하려면?
  - 1. 컴포넌트 외부에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
  - 2. 이 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고, 상태가 변할 때마다 리렌더링을 발생시켜 최신 값을 사용할 수 있어야 한다.
  - 3.  상태가 객체인 경우, 감지하는 프로퍼티가 아닌 다른 프로퍼티가 업데이트될 떄는 리렌더링이 될 필요가 없다.

### 3. subscribe를 구현한다

[](./globalState/store.js)

- 상태를 내부 변수로 가지는 Store를 생성한다.
- **Store는 상태 변화에 따라 컴포넌트가 자동으로 리렌더링될 수 있게 하는 역할이다.**
- get: 최신 상태를 반환
- set: 내부 변수를 최신화하고, 등록된 콜백을 모조리 실행
- subscribe: 상태를 사용하려는 컴포넌트에서 콜백을 인자로 받아 Set에 등록 및 저장

[](./globalState/storeHooks.js)

- 컴포넌트에서 Store에서 상태값을 사용하려면 컴포넌트마다 get을 호출하여 상태값을 반환하고, set 함수를 반환하고, subscribe를 호출하여 구독하는 과정이 필요하다.
- 이 반복적인 과정을 사용자 정의 훅으로 만들면 편하게 사용할 수 있다.

[](./globalState/useStore.js)

- 2 에서 발생했던 컴포넌트간 상태 불일치 문제가 해결되었다.
- 하지만 아직 3번 조건이 해결되지 않았다. 상태값이 객체라면 객체 전체를 전부 수정해야 한다.
- 리덕스의 useSelector 훅은 useStore의 get, subscribe와 비슷한 역할을 할 것 같다. useSelector는 Store를 지정하지 않아도 되는 것으로 기억한다.

### 4. selector를 구현한다

[](./globalState/storeHooks.js)

- useStore 훅과 비교하여 selector를 인자로 받고, 내부적으로 프로퍼티를 선택하여 useState에 할당하였다.
- 상태값의 범위를 좁혀서 불필요한 리렌더링을 막는 효과가 있다.
- useStoreSelector 훅에 전달하는 selector는 메모이제이션이 반드시 되어야 한다. 그렇지 않으면 useEffect 콜백이 계속 실행되면서 unsubscribe, subscribe를 계속 반복하게 된다. 결과적으로 리소스가 낭비된다.

### useSubscription

- useStore 훅과 비슷하게 상태값을 반환하고 컴포넌트를 Store에 구독하는 과정을 대신하는 훅이다.
- Store를 인자로 받지 않고, subscription 객체를 통해 클로저로 접근하는 차이점이 있다.
- 인자로 주어지는 함수가 변경되는 경우 이를 무시하고 한정적으로 원하는 값을 반환하게끔 예외 처리를 하여, useStore 훅보다 더 안정적으로 상태를 제공할 수 있다.

## useState와 Context를 동시에 사용해보기

- Store를 import / export를 이용해서 사용해도 되는데, Context를 사용하면 좋은 이유?
- Store를 외부에서 주입하기 때문에, 결합도를 낮추고 테스트 및 수정하기가 용이해진다.

### 1. import / export를 통해 Store를 사용하는 방법

- Store를 import하여 어느 컴포넌트에서나 접근 가능하게 하는 방법이다.

```tsx
// counterStore.js
export const counterStore = createStore({ count: 0 });

// App.js
function App() {
  return <Count />;
}

// Count.js
import { counterStore } from "./counterStore";

function Count() {
  const [state, setState] = useStore(counterStore);
  return <div>{state.count}</div>;
}
```

- 이렇게도 충분히 사용할 수 있다.
- 하지만 문제는 모든 컴포넌트가 counterStore.js에 직접 의존한다는 것이다.
  - 1. 모듈 의존성 증가: 모든 컴포넌트가 Store를 직접 import하고 있으면, Store 구조나 위치가 바뀌었을 때 컴포넌트 코드도 수정해야 한다.
  - 2. 테스트의 어려움: Store와 강하게 결합된 컴포넌트는 이를 모킹하거나 교체하기 어렵기 때문에, 독립적인 테스트가 어렵고 번거로워진다.

```tsx
// Count.test.js
import React from "react";
import { render } from "@testing-library/react";
import Count from "./Count";

test("renders count value from store", () => {
  const { getByText } = render(<Count />);
  expect(getByText("0")).toBeInTheDocument();
});
```

- Store을 모킹하기 위해서는 Count.js를 직접 수정해야 하는 번거로움이 있다.

### 2. Context를 이용하여 Store를 사용하는 방법

- Context API: 상태 관리 도구가 아니라, 상태값을 하위 컴포넌트로 주입해주는 기능이다.

```tsx
// CounterStoreContext.js
export const counterStore = createStore({ count: 0 });
export const CounterStoreContext = createContext();

export const CounterStoreProvider = ({ store, children }) => {
  return (
    <CounterStoreContext.Provider value={store}>
      {children}
    </CounterStoreContext.Provider>
  );
};

// App.js
function App() {
  return (
    <CounterStoreProvider store={counterStore}>
      <Count />
    </CounterStoreProvider>
  );
}

// Count.js
function Count() {
  const store = useContext(CounterStoreContext);
  const [state, setState] = useStore(store);
  return <div>{state.count}</div>;
}
```

- 외부에서 Store를 주입하고, Count.js는 useContext를 통해 주입된 Context를 통해 Store를 참조하게 된다.
- 외부에서 값을 수정할 수 있기 때문에 의존성이 낮아지고 테스트하기가 용이해지는 장점이 있다.

```tsx
// Count.test.js
import React from "react";
import { render } from "@testing-library/react";
import Count from "./Count";
import { CounterStoreProvider } from "./CounterStoreContext";

const mockStore = createStore({ count: 100 });

test("renders count value from the mock store", () => {
  const { getByText } = render(
    <CounterStoreProvider store={mockStore}>
      <Count />
    </CounterStoreProvider>
  );
  expect(getByText("100")).toBeInTheDocument();
});
```

- 리덕스도 이런 비슷한 구조를 띄고 있는 것으로 보아, 내부적으로 Context를 사용하고 있는 것 같다.

### 3. Context를 이용하여 가장 가까이 주입된 Store를 사용하는 방법: 책 예제

- 부모 컴포넌트 입장에서는 자신이 자식 컴포넌트에 따라 보여주고 싶은 데이터를 Context로 잘 격리하면 된다.
- 부모와 자식 컴포넌트의 책임과 역할을 이름이 아닌 명시적인 코드로 나눌 수 있어 코드 작성이 용이해진다.

### 정리

- 컴포넌트 내부로 한정되는 지역 상태(useState, useReducer)의 한계를 극복하기 위해 외부에 전역 상태를 두는 방법이 고안되었다.
- 첫 번째는 루트 컴포넌트 또는 부모 컴포넌트로 끌어 올리는 방법이다.
- 두 번째는 루트 컴포넌트 외부의 격리된 스코프에 스토어를 생성하는 방법이다.
- 어떠한 방법이더라도 전역 상태가 변경된다면, 이를 사용하는 모든 컴포넌트에 렌더링을 발생시켜야 한다.

- 지금까지 Provider가 상태값을 담아두는 곳 쯤으로 알고있어서 컴포넌트 최상단에 위치시켜야 한다고 생각했는데 이게 아니었다. (조금 부족한 설명이다.)
- **컴포넌트 외부에 Store가 존재하고, 전달한 Store를 통해 상태값을 사용할 수 있게 주입해주는 역할이었던 것이다.**

- 사용했던 방식 정리

  - 영어 회화: Store를 사용한 것은 아니고, Context API만 사용하였다. 루트 컴포넌트에 useState로 상태값을 생성하고, useContext를 통해 상태값을 받아오는 방식으로 사용하였다.
  - 트센: 컴포넌트와 분리된 단일 Store를 사용하였다. useSelector를 사용하여 상태값 받아오기, 구독을 처리하였다. 명시적으로 Context는 사용하지 않았다.

## 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

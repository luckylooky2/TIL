### entry
- 단일 입력(string), 다중 입력(string[])
- 간단한 규칙: HTML 페이지 당 하나의 엔트리 포인트. SPA: 하나의 엔트리 포인트, MPA: 다중 엔트리 포인트
- 동적으로 로드된 모듈은 엔트리 포인트가 아님
- 2개 이상의 엔트리 포인트에 대해서 하나의 파일로 합칠 수 없다
- [webpack-cli] Error: Conflict: Multiple chunks emit assets to the same filename output.js (chunks 57 and 594)
- `[name].js` 처럼 substitution을 이용하여 다중 출력을 가능하게 하자

### output
- 번들링된 코드를 저장할 파일시스템 경로
- `output: { filename: "output-[name].js", path: __dirname }`
- output.path의  기본값은 `path: __dirname + "/dist"`로 추정됨

### devtool
- 오류와 경고를 쉽게 추적할 수 있도록, JavaScript는 컴파일된 코드를 원본 소스로 매핑하는 소스맵을 제공
- https://webpack.kr/configuration/
- Source map
	- 소스 맵은 *번들된 코드*와 *원본 소스 코드* 간의 매핑 정보를 포함한 파일
	- 이를 통해 개발자 도구에서 *번들된 코드*를 *원본 코드*로 매핑해 디버깅할 수 있게 해줌
	- 보통 번들링된 파일은 uglify 과정을 거쳐 난독화됨
		- 소스 맵은 난독화된 번들링 파일을 원본 소스로 복원하는 역할
- `eval-*`: 모듈별로 소스맵을 생성하고 eval을 통해 추가, 리빌드 성능이 개선되어 개발에 권장
- `inline-*`: 소스맵을 별도의 파일을 만드는 대신 원본 파일에 인라인으로 추가
- `hidden-*`: 소스맵에 대한 참조가 추가되지 않음. 오류 보고 목적 등, 소스맵을 배포히지 않지만 반드시 생성되어야 하는 경우에 사용

#### 1. `devtool: false`
![[Pasted image 20240820135846.png]]
![[Pasted image 20240820135949.png]]
- *PRODUCTION*
- quality: bundled(모듈 분리 x)
- 번들 파일 크기: 462KB
- 소스 맵을 설정하지 않도록 설정
	- 소스 맵이란 원본 파일을 변환한 후에도, 원본 파일과의 매핑 정보를 포함하는 파일
	- 매핑 정보를 통해 브라우저는 디버깅 시 원본 소스 파일을 보여줄 수 있음
- 즉, 원본 소스 파일을 알 수 없음
- 과정
	- 트랜스파일링 => Terser => 번들링 => 번들 파일
- 장점
	- 번들링된 파일을 단일 파일로 취급하고, 소스 맵이 없기 때문에 원본 코드를 알 수 없음\
	- 소스 맵을 포함하지 않고, 트랜스파일링 코드도 포함하지 않아 번들 크기가 매우 효율적
- 단점
	- 그렇기 때문에 오류 발생 시, 발생 모듈을 찾기 힘들어 디버깅이 어려운 단점이 있음
- 그렇기 때문에, 프로덕션 용도에 적합

#### 2. `devtool: eval`
![[Pasted image 20240820142720.png]]
![[Pasted image 20240820142407.png]]
- *DEVELOPMENT*
- 브라우저 source 탭에 front-assignment-chanhyle 이라는 path에 node_modules가 생겼음
- quality: generated(모듈 분리, 모듈 이름 주석 표시)
- 번들 파일 크기: 1.6MB
- 소스 맵을 사용하지 않고도, `eval()`을 이용하여 각 모듈의 *트랜스파일링된 코드*가 브라우저의 개발자 도구에서 직접적으로 제공
	- cf> 번들링된 코드가 빌드될 것이라고 생각했는데, 결과적으로는 번들링되기 전의 트랜스파일링된 코드를 `eval()` 내에서 실행
		- 즉, Terser로 압축하기 전의 코드를 실행하기 때문에 Uglify가 적용되지 않은 것
		- 트랜스파일링 => `eval()` 적용 => Terser => 번들링 => 번들 파일
	- 소스 맵은 사용하지 않음
		- 그렇기 때문에 빌드 시간은 더 빠름
		- 트랜스파일링 이전의 원본 파일을 확인할 수 없음
	- 각 모듈이 독립적으로 eval()로 감싸져 있어, 개발자 도구에서 해당 모듈의 번들링된 소스를 직접 확인할 수 있음
		- `eval("console.log('Hello, World!');\n\n//# sourceURL=webpack:///./src/app.js?");`
	- `sourceURL` 정보를 통해 브라우저에서 디렉토리 구조와 위치를 파악 및 추적 가능
		- 위의 front-assignment-chanhyle은 `eval()`로 작성된 코드를 토대로 구성
- 장점
	- 소스 맵을 포함하지 않고, 트랜스파일링 코드(`eval`)만 포함하여 번들 크기가 비교적 낮고, 빌드 속도가 빠른 편
	- *트랜스파일링된 코드를 모듈의 위치와 함께 표시함으로써* 브라우저에서 소스 코드의 디렉토리 구조나 위치를 알 수 있게 함으로써 디버깅을 쉽게 함
- 단점
	- ***하지만 트랜스파일링된 코드로 인해 디버깅이 불편할 수 있음***
		- `eval-source-map`을 권장
	- 프로덕션 모드에서는 사용할 수 없음
		- 트랜스파일링 코드 포함
		- `eval()` 자체의 보안적 위험성

#### 3. `devtool: eval-source-map`
![[Pasted image 20240820144959.png]]
![[Pasted image 20240820145023.png]]
![[Pasted image 20240820145041.png]]
- *DEVELOPMENT*
- 직접 소스 맵을 생성하지는 않고, *인라인 소스 맵* 방식을 사용
- 번들링된 파일 `main.js` 에서 
	1.  `//# sourceURL=webpack-internal:///./index.js`를 통해 인라인 소스 맵을 간접 참조
	2. `webpack-internal:///./index.js`에 주석으로 `//# sourceMappingURL` 원본 소스 코드를 참조
	3. `front-assignment-chanhyle/index.js`에 실제 원본 코드가 존재
- quality: original(모듈 분리, 트랜스파일 전의 원본 코드를 볼 수 있음)
- 번들 파일 크기: 4.1MB
- 장점
	- `eval`이 트랜스파일링된 코드만 볼 수 있었다면 `eval-source-map`은 완전한 소스 코드를 볼 수 있음
- 단점
	- `eval()`을 이용한 트랜스파일링 코드와 인라인 소스 맵을 모두 포함하기 때문에 번들 파일 크기가 매우 큼. 그에 따라 빌드 속도도 매우 낮음
	- 역시 `eval()`을 사용하고 원본 소스 코드를 그대로 노출하기 때문에 프로덕션 용도로는 적절하지 못함

#### 4.`devtool: inline-source-map`
![[Pasted image 20240820151548.png]]
![[Pasted image 20240820151622.png]]
![[Pasted image 20240820151645.png]]
- *DEVELOPMENT*
- **소스 맵이 인라인으로 포함**: `main.js.map`과 같은 소스 맵 정보가 별도의 파일로 생성되지 않고, 번들링 파일 안에 인라인 주석으로 포함
	- `//# sourceMappingURL=data:application/json;charset=utf-8;base64...`
	- 번들 파일 가장 하단에 base64로 인코딩된 소스 맵 정보를 주석으로 포함
- quality: original(모듈 분리, 작성한 원본 코드 표시)
- 번들 파일 크기: 3.4MB
- `eval-source-map`과는 다르게 소스 맵 주석이 번들 파일에 포함
- `eval()`을 사용하지 않아 트랜스파일링된 코드가 아닌 모든 원본 코드에 Uglify가 적용된 번들 파일
- 장점
	- 완전한 소스 코드를 볼 수 있음
	- 디버깅이 편함
- 단점
	- 소스 맵을 포함하므로 번들 파일의 크기가 상당히 커질 수 있음
	- 보안 취약점: 원본 소스 코드가 외부에 노출되기 때문에 프로덕션 용도로는 적절하지 못함

#### 5. `devtool: source-map`
![[Pasted image 20240820153027.png]]
![[Pasted image 20240820153057.png]]
![[Pasted image 20240820153116.png]]
- *PRODUCTION?*
- `main.js.map`과 같은 소스 맵 정보가 파일로 생성되고, 빌드된 파일에 소스 맵의 *참조*가 주석으로 포함
	- 번들 파일에 소스 맵 전체를 포함하는 것이 아니라, 참조 주소만 포함
- 소스 맵 파일을 서버에서 어떻게 가져오는지를 확인하는 방법은 아직 찾지 못함
- quality: original(모듈 분리, 작성한 원본 코드 표시)
- 번들 파일 크기: 462KB
- **Settings** > **Preferences** > **Sources** > Enable JavaScript source maps로 활성화 / 비활성화 가능
- 장점
	- `inline-source-map`처럼 번들 파일에 포함시키지 않아서 번들 파일 크기가 매우 작음
- 단점
	- 큰 소스 맵 파일을 가져오기 위해 서버에 비동기 요청이 필요
- 원본을 볼 수 있는데 프로덕션 용도로 배포해도 되는 이유는 무엇인가?

#### 6. `devtool: hidden-source-map`
![[Pasted image 20240820160022.png]]
![[Pasted image 20240820160039.png]]
- *PRODUCTION*
- 빌드 시에 소스 맵(`main.js.map`)을 함께 빌드하지만, 브라우저에서는 보이지 않도록 설정
	- 보이지 않는다는 뜻은?
	- *번들 파일에 소스 맵 참조를 포함하지 않기 때문* :  `//# sourceMappingURL=filename.map`과 같은 주석
- 브라우저는 번들 파일만 로드할 때, 소스 맵의 존재를 알 수 없으며 원본 소스 코드을 참조하지 않음
- 번들 파일 크기: 462KB
- quality: original(모듈 분리, 작성한 원본 코드 표시)
- 소스 맵 파일은 서버에 업로드되거나 안전한 장소에 저장될 수 있으며, 발생한 오류를 디버깅할 때만 접근할 수 있도록 함
	- cf> 일반 사용자가 소스맵 파일에 접근 할 수 없도록 서버를 구성해야합니다!
	- cf> 소스맵 파일을 웹 서버에 배포해서는 안됩니다. 오류 보고 툴링에만 사용하세요.
- 소스 맵을 빌드하긴 하지만 오류 보고 툴 이외에는 사용하지 않는다면, 외부에 노출되지는 않음
	- `inline-source-map` 과의 차이점

### module
### plugins
# 1.2 함수

- 자바스크립트에서 사용하는 함수와 형태가 같다.
- 리액트에서의 함수 컴포넌트와 일반 함수와 호출하는 방법에 조금 차이가 있다.

```jsx
// 일반 함수 호출
Component(props);

// 함수 컴포넌트 호출
// 물론 일반 함수처럼 호출하는 것도 가능하다.
<Component name="chanhyle">
<Component {...props}>
```

## 함수를 정의하는 4가지 방법

- 각 방법마다 기술적인 차이가 조금씩 존재한다.

### 1. 함수 선언문

```js
function add(a, b) {
  return a + b;
}
```

- 가장 일반적인 방식
- 함수 리터럴을 선언문으로 사용한 방식이다.(표현식으로도 사용할 수 있다.)
- 표현식(expression)이 아닌 **문(statement)**이다. 표현식은 값을 산출하고, 문은 값을 산출하지 않는다.

### 2. 함수 표현식

```js
// 표현식에서의 함수 이름은 생략하는 편인데, 내부적으로밖에 사용할 수 없기 때문이다.
const sum = function add(a, b) {
  return a + b;
};

sum(10, 24);
add(10, 24); // Uncaught ReferenceError: add is not defined
```

- 자바스크립트 엔진은 코드의 문맥에 따라 동일한 함수 리터럴을 선언문이 아니라 표현식으로 해석하는 경우도 있다.
- 함수가 표현식으로 해석될 수 있는 이유는 자바스크립트에서 **일급 객체**이기 때문이다.
- 일급 객체는 1) 변수에 할당 2) 매개변수로 사용 3) 반환 값으로 사용할 수 있어야 한다.

### 선언문과 표현식의 차이: 호이스팅

- 호이스팅: 코드를 실행하기 전에 식별자를 미리 메모리에 등록하는 작업을 의미한다.
- 함수 선언문은 메모리에 등록하면서 함수 객체으로 초기화가 되지만, 함수 표현식은 메모리에 변수 이름만 등록하고 실제 초기화는 변수에 함수 객체를 할당할 때 이루어진다.

```js
// 선언문 장점: 위치에 구애받지 않고 사용할 수 있다.
hello(); // changed hello
console.log(hello2); // undefined
hello2(); // Uncaught TypeError: hello is not a function

function hello() {
  console.log("hello");
}

// 표현식 장점: 절차적 프로그래밍 흐름대로 코드를 예측하기 쉽다.
var hello2 = function () {
  console.log("hello2");
};

// 선언문 단점: 함수 선언문으로 사용하면, 이름이 중복될 경우 덮어씌워지는 문제가 발생한다.
function hello() {
  console.log("changed hello");
}
```

### 3. Function 생성자

```js
const add = new Function("a", "b", "return a + b");
```

- 잘 사용하지 않는 방법이다.
- 인자를 모두 문자열로 작성해야 하기 때문에 직관적이지 않다.
- **클로저가 생성되지 않는다**는 단점이 있다.

### 4. 화살표 함수(ES6)

```js
const add = (a, b) => {
  return a + b;
};

// 축약형
const add = (a, b) => a + b;
```

- 사용하기 짧고 쉬워서 많이 사용하는 방식이다.
- 하지만 함수 표현식 / 선언문과 중요한 차이점이 존재한다.

- (1) **this 바인딩이 존재하지 않는다.**
  - 함수 선언문 / 표현식은 어떤 방식으로 호출되는가에 따라 동적으로 `this`가 바인딩되는데, 화살표 함수는 어떤 방식으로 호출되던간에 `this`가 바인딩되지 않는다.
  - 대신 상위 스코프의 `this`(lexical this)를 그대로 따르게 된다.
  - 즉, 함수를 호출하는 방법이 아닌, 함수가 선언된 위치에 따라 `this`를 결정해야 할 때 사용된다.
  - 리액트의 클래스 컴포넌트에서 `this.state`나 `this.setState` 등 내부적으로 `this`를 사용하는 함수는 화살표 함수로 반드시 정의해야 하는 이유이다.
- (2) **constructor가 존재하지 않기 때문에 new와 함께 사용할 수 없다.**
- (3) **arguments가 존재하지 않는다.**

```js
const hello = () => {
  console.log(this);
};

// babel ES5 트랜스파일
// - 기존 함수 표현식과 매우 유사하기 때문에 아래처럼 단순한 변환으로 동작을 유지할 수 있다.
// - 트랜스파일링 시에도 특별한 성능 부담이 발생하지 않는다.
var _this = this;

const hello = function () {
  console.log(_this);
};
```

## 리액트에서 자주 쓰이는 함수

### 1. 즉시 실행 함수

- 보통 일반 함수는 정의하는 시점과 실행하는 시점이 다르다.
- 즉시 실행 함수는 정의하는 그 순간 즉시 실행되는 점에서 일반 함수와 차이가 있다.
- 선언: 변수나 함수의 존재와 타입을 알리는 행위이며, 메모리 할당이나 구체적인 구현을 포함하지 않을 수 있다.
- 정의: 실제로 메모리 할당을 하거나, 구체적인 동작을 구현하는 것이다.

```js
// 선언(정의)
function add(a, b) {
  return a + b;
}

// 실행
add(10, 24); // 34

// 선언(정의) 및 실행
(function (a, b) {
  return a + b;
})(10, 24); // 34
```

- 특징
  - (1) 단 한 번 밖에 호출할 수가 없다. 그래서 대부분 이름을 붙이지 않는다.
  - (2) 정의된 변수들이 외부로 노출되지 않으므로 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 얻을 수 있다. 외부에서는 즉시 실행 함수 내부로 접근이 불가능하기 때문이다.

```js
const [increment, getCounter] = (function () {
  // 함수 내부가 아니고서는 접근이 불가능하다.
  let counter = 0;

  function increment() {
    counter++;
  }

  function getCounter() {
    console.log(counter);
  }

  return [increment, getCounter];
})();

const [increment2, getCounter2] = (function () {
  // 정의된 변수들이 외부로 노출되지 않아서 변수 이름 중복 위험이 없다.
  let counter = 0;

  function increment() {
    counter++;
  }

  function getCounter() {
    console.log(counter);
  }

  return [increment, getCounter];
})();

increment();
increment();
increment();
getCounter(); // 3
increment2();
getCounter2(); // 1
getCounter(); // 3
```

### 2. 고차 함수

- 함수가 일급 객체라는 특징을 활용하여, 함수를 인자로 받거나 함수를 반환하는 함수를 고차함수라고 한다.
- 대표적인 예시로, `Array.prototype.map`, `Array.prototype.filter` 등이 있다.
- 이를 리액트에 적용해 **함수 컴포넌트를 인자로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수 컴포넌트**를 만들 수 있다.
- 장점: 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적으로 리팩터링 할 수 있다.

```js
const add = function (a) {
  // 반환하는 함수에서는 변수 a에 대한 클로저에 접근할 수 있기 때문에 return a + b가 가능하다.
  // 변수 a에 대한 정보를 저장하는 새로운 함수를 만들 수 있다.
  return function (b) {
    return a + b;
  };
};

const addToOne = add(1);
addToOne(3); // 4
addToOne(10); // 11
```

## 함수를 만들 때 주의해야 할 사항

- 목적: 가독성을 높이고, 유지보수를 조금 더 쉽게 하기 위함이다.

- **함수의 부수 효과를 최대한 억제하라**
  - 부수 효과(side-effect): 함수 실행으로 인해 함수 외부에 영향을 미치는 것 e.g. API 호출, `console.log`, 상태값 변경
  - 순수 함수: 부수 효과가 없고, 동일한 인수에 대해 동일한 결과를 반환하는 함수
  - 부수 효과가 적으면 좋은 점? _결과에 대한 예측이 비교적 쉽고 안정적이다._
  - 모든 함수를 순수 함수로 작성할 수는 없기 떄문에, 부수 효과를 최대한 작게 만드는 방향으로 함수를 설계해야 한다.
  - `useEffect`: 부수 효과를 명확하게 관리할 수 있는 방법을 제공하는 훅. 이 훅의 작동을 최소화하는 방향이 바람직하다고 볼 수 있다.
  - 부수 효과가 발생하는 범위를 명확하게 관리하고 필요한 곳에서만 발생시키는 것을 목표로 한다.
  - `useEffect`를 이용하여 부수 효과를 최소화 하는 방법
    - 기능에 따라 최대한 분리하고 관련 있는 기능끼리는 묶어서, 부수 효과의 예측을 쉽게 하고 확대를 억제한다.
    - 의존성 배열을 활용하여 불필요한 렌더링을 방지한다.
    - cleanup 함수를 설정하여 부수 효과를 적절히 해제한다.
- **가능한 한 함수를 작게 만들어라**
  - _"함수는 하나의 일을, 그 하나만 잘하면 된다."_
  - 함수를 작게 만드는 편이 함수의 원래 목적인 재사용성을 높이는데 유리하다.
- **누구나 이해할 수 있는 이름을 만들어라**
  - 실제 배포에는 Terser를 이용해 함수나 변수 이름의 의미가 없어지므로, 이름의 길이가 성능에는 영향을 미치지 않는다.
  - 익명 함수를 기명 함수로 바꾸는 것도 직관적으로 함수의 역할을 이해하는데 도움이 된다.

```js
useEffect(function apiRequest() {
  // ... do something
}, []);
```

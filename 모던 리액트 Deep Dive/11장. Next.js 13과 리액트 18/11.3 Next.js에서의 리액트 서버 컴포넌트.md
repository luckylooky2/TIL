# 11.3 Next.js에서의 리액트 서버 컴포넌트

- 기본적인 서버 컴포넌트는 리액트 서버 컴포넌트와 동일하다.
  - 클라이언트 컴포넌트는 서버 컴포넌트를 불러올 수는 없고, children props로 받아서 렌더링만 가능하다.
- page.tsx는 루트 컴포넌트가 되어 서버 컴포넌트이다.
- layout.tsx는 반드시 서버 컴포넌트이다.

## 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- app router에서는 위와 같은 메서드가 삭제되고 fetch 기반으로 변경되었다.
- 페이지 컴포넌트에서 fetch를 통해 직접 데이터를 불러올 수 있고, async 키워드도 사용할 수 있다.
- 리액트 팀(?)은 fetch API를 확장하여 요청 중복을 방지했다.
- 서버에서는 fetch 요청을 렌더링이 한 번 끝날 때까지 캐싱(동일한 fetch 요청이 한 번만 발생하고 캐싱된 데이터를 재사용)하며, 별도의 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

## 정적 렌더링과 동적 렌더링

- Next.js 13
- 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 해두고 캐싱해 재사용할 수 있게 되었다.
  - 내부에서 비동기 요청을 하더라도 빌드 타임에 렌더링을 해두고 캐싱해두기 때문에, 빌드 타임에 렌더링된 결과물을 재사용한다.
  - 캐싱을 비활성화하려면, `fetch(url, { cache: 'no-cache' })` 또는 `fetch(url, { next: { revalidate: 0 } })`으로 fetch를 호출한다.
  - next/cookie, next/header 패키지를 사용한다면, 정적 렌더링에서 제외된다.
- 동적인 라우팅에 대해서는 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.
  - 동적 라우팅인데 캐싱이 필요할 경우(getStaticPaths)에는, 새로운 메서드인 generateStaticParams를 사용한다.

## 캐시와 mutating, 그리고 revalidating

- Next.js는 fetch의 기본 동작을 재정의해 캐싱을 적용했다.
- 위에서 revalidate를 이용해 캐시 유효 시간을 설정했었는데, 변수로 설정하는 방법도 존재한다. 하위 라우팅 영역에 모두 영향을 미친다.

```tsx
// app/page.tsx
export const revalidate = 60;
```

- 동작 방식

  1. 최초로 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
  2. 이 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
  3. 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
  4. 내부적으로는 백그라운드에서 캐시를 업데이트한다.
  5. 4번의 작업이 성공하면 갱신하고, 아니라면 과거 데이터로 유지한다.

- 캐시를 전체적으로 무효화하고 싶다면, `router.refresh()`를 사용한다: 브라우저의 히스토리에 영향을 미치지 않고 갱신한다. 브라우저나 리액트의 state에는 영향을 미치지 않는다.

## 스트리밍을 활용한 점진적인 페이지 불러오기

- 과거에는 하이드레이션이 끝나야만 페이지 하나를 온전하게 볼 수 있다.
- 페이지가 완성될 때까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 클라이언트에 점진적으로 보내는 스트리밍이 도입되었다.
- 장점
  - 사용자가 일부라도 페이지와 인터랙션을 할 수 있다.
  - Time to First Byte(TTFB)를 줄일 수 있고, First Contentful Paint(FCP)를 빠르게 할 수 있다.
  - 사용자는 기다림과 지루함을 덜 수 있다.
  - 페이지가 로딩 중이라는 인식을 더 명확하게 심어줄 수 있다.
- loading.tsx 컴포넌트를 사용하거나 <Suspense /> 컴포넌트를 직접 사용할 수 있다.

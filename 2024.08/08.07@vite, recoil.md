## vite

- create-react-app의 대체재라고 생각하면 될 듯?
- script, lint, typescript, 트랜스파일러, 기본적인 뼈대 등 초기 세팅을 해주는 역할

```shell
npm create vite@latest
```

## SWC

- babel(트랜스파일러)의 대체재
- Rust로 만들었고, 최적화 측면에서 babel보다 빠르고 좋다고 할 수 있다
- babel의 단점을 아직 못 느껴봐서 큰 감흥은 없다
- (왜 SWC를 사용해야 하는가?) https://velog.io/@kwonhygge/Next-JS%EA%B0%80-Babel%EC%9D%84-SWC%EB%A1%9C-%EB%8C%80%EC%B2%B4%ED%95%9C-%EC%9D%B4%EC%9C%A0

## Recoil

- 상태 관리 라이브러리
- Redux 처럼 Flux(Action Dispatch) 방식은 아님 => Atomic(React state와 비슷하게 트리 안에서 상태를 저장하고 관리)
- 새로 고침하면 Recoil State가 증발한다 => recoil-persist 라이브러리를 사용하면 recoil state가 날라가지 않고 sessionStorage 또는 localStorage에 보관된다
- (무슨 의미?) 상태 정의는 점진적이고(incremental) 분산되어 있기 때문에, 코드 분할이 가능하다

- (Recoil 장점) https://recoiljs.org/ko/docs/introduction/motivation/
- (차이점) https://velog.io/@iberis/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B9%84%EA%B5%90-Redux-vs-Recoil-vs-Zustand-vs-Jotai

### 핵심은 `atom`과 `selector`이다

1. `atom`

- _상태의 단위_ 이며, 업데이트와 구독이 가능
- atom이 업데이트되면 각각 구독된 컴포넌트는 새로운 값을 반영하여 다시 렌더링
- key: 전역적으로 고유
- default: 상태의 기본값
- atom을 업데이트와 구독하기 위해서는 `useRecoilState`라는 훅을 사용
- 구독만 하기 위해서는 `useRecoilValue`라는 훅을 사용
- 업데이트만 하기 위해서는 `useSetRecoilState`라는 훅을 사용

```ts
export const todoListState = atom<Todo[]>({
  key: "todoListState",
  default: [],
});

const todoList = useRecoilValue(todoListState);
```

2. `selector`

- atoms나 다른 selectors를 입력으로 받아들이는 순수 함수(pure function)
- selector는 _상태를 기반으로 하는 파생 데이터를 계산하는데 사용됨_
- atom과 마찬가지로 입력된 atoms, selectors가 변경되면 해당 selector도 다시 실행됨
- 캐싱: 입력이 바뀌지 않으면, 저장해 놓은 상태값을 다시 가져오지 않고 재사용

```tsx
export const filteredTodoListState = selector({
  key: "filteredTodoListState",
  // get 속성: useRecoilValue를 사용할 수 있음
  get: ({ get }) => {
    const filter = get(todoListFilterState);
    const list = get(todoListState);

    // 캐싱: 위의 filter와 list가 동일할 경우, 처음 한 번만 출력 및 실행됨
    console.log("console log for checking caching");

    // filter 값에 따라 list의 파생 데이터를 만들어 냄
    switch (filter) {
      case "Show Completed":
        return list.filter((item: Todo) => item.isComplete);
      case "Show Uncompleted":
        return list.filter((item: Todo) => !item.isComplete);
      default:
        return list;
    }
  },
});

const todoList = useRecoilValue(filteredTodoListState);
```

- get 속성의 콜백 함수로 주어지는 `get`을 통해 다른 atom, selector에 접근할 수 있음
- 컴포넌트의 관점에서 보면 selectors와 atoms는 동일한 인터페이스를 가지므로 서로 대체할 수 있음
- atom과 마찬가지로 `useRecoilState`, `useRecoilValue`, `useSetRecoilState` 훅을 사용할 수 있음
- 파생된 상태값만 구독하기 위해서는 `useRecoilValue`라는 훅을 사용. set 속성이 없는 selector는 구독만 가능
- get 속성 뿐만 아니라 set 속성이 정의된 selector는 `useRecoilState`훅을 사용하여 구독 및 업데이트가 가능

### `useState` vs Recoil

`useState`

- 지역 상태 관리 변수
- 공유될 필요가 없거나 바로 아래 컴포넌트에만 사용되는 경우
- prop drilling이 깊게 발생하지 않게, Recoil이 대안이 될 수 있음

Recoil

- 전역 상태 관리 변수: 여러 컴포넌트에서 공용으로 사용할 수 있는 상태값

### selector의 비동기 요청 처리

- selector에서도 비동기 함수 호출을 통해 상태값을 결정할 수 있음
- Promise를 리턴하는 get 속성 함수를 작성해야 함
- Recoil은 보류중인 데이터를 다루기 위해 React Suspense와 함께 동작하도록 디자인되어 있음
- Suspense를 사용하지 않으면, 다른 컴포넌트도 같이 렌더링되지 않는 이슈가 발생할 수 있음
- 컴포넌트를 Suspense의 경계로 감싸는 것으로 아직 보류중인 하위 항목들을 잡아내고 대체하기 위한 UI를 렌더

```ts
export const getMyInfoState = selector({
  key: "getMyInfoState",
  get: () => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({ username: "chanhyle", lastLogin: new Date().toUTCString() });
      }, 3000);
    });
  },
});
```

```tsx
const MyInfo = () => {
  const { username, lastLogin } = useRecoilValue(getMyInfoState);

  return (
    <section>
      <h1>{username}</h1>
      <h3>Last Login: {lastLogin}</h3>
    </section>
  );
};

const TodoList = () => {
  const todoList = useRecoilValue(filteredTodoListState);

  return (
    <>
      <Suspense fallback={<div>Loading...</div>}>
        <MyInfo />
      </Suspense>
      <TodoListStats />
      <TodoListFilter />
      <TodoItemCreator />
      {todoList.map((todoItem, i) => (
        <TodoItem item={todoItem} key={i} />
      ))}
    </>
  );
};
```
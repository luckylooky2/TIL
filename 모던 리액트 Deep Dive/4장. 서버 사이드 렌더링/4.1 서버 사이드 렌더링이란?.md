# 4.1 서버 사이드 렌더링이란?

- SSR 코드를 작성할 때, SPA를 만드는 것보다 신경쓸 점이 훨씬 많다.

## 싱글 페이지 애플리케이션의 세상

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식을 의미한다.
- 페이지 전환을 위한 모든 작업이 자바스크립트 리소스와 브라우저의 `history.pushState`, `history.replaceState` API로 이루어진다.
- 서버로부터 페이지를 불러오면 이후에는 더 이상 서버에서 페이지를 불러올 필요가 없다.
- `<body>`에 아무런 내용이 없다.
- 장점) 한 번 로딩된 이후에는 받아올 리소스가 비교적 적다. 단점) 최초 로딩 리소스가 매우 크다.

### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

- 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱하는 작업을 매번 거쳤다.
- 이러한 과정은 화면이 바뀔 때마다 깜빡깜빡하며 부자연스럽다.
- SPA는 페이지 전환에 필요한 일부 영역만 다시 그리기 때문에 훨씬 매끄러워진다.

### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- PHP 등 예전에는 렌더링이 대부분 서버 사이드에서 진행되었다. 자바스크립트는 사용자에게 보조적인 수단에 불과했다.
- 역할 확대 기여
  - 자바스크립트 모듈화(CommonJS, AMD)
  - 자바스크립트 프레임워크(Backbone.js, AngularJS): 서버에서만 할 수 있는 작업이 가능
- **이제는 페이지 렌더링에서 사용자 인터렉션까지** 자바스크립트가 웹 애플리케이션에서 없으면 안 될 정도로 역할이 확대되었다.
- SPA는 프론트엔드 개발자들에게 좀 더 간편한 개발 경험을 제공하여 간편하게 웹 앱을 만들 수 있게 해주었다.
- SPA의 활용
  - JAM(Javascript, API, Markup) 스택: JS, HTML, CSS를 미리 빌드하고 정적으로 사용하는 방법
  - MEAN, MERN 스택: API 서버도 자바스크립트로 구현하는 방법

### 새로운 패러다임의 웹 서비스를 향한 요구

- SPA가 확대되면서 자바스크립트 코드 크기가 커졌다. 하지만 사용자 기기나 인터넷 환경이 이러한 단점을 커버해 줄 것이라고 기대하였다.
- 결과적으로 코드 크기가 커진만큼 처리 시간이 줄어들지 않았다. 즉, 사용자는 더 많은 시간을 기다려야 한다.
- SSR이 등장하게 된 배경이다.

## 서버 사이드 렌더링이란?

- SPA가 하나의 페이지에서만 자바스크립트로 렌더링을 수행한다면, SSR은 **최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식이다.**
- 즉, 웹 페이지 렌더링의 책임을 어디에 두는가이다.
  - SPA: 자바스크립트 번들에서 렌더링을 담당한다. 사용자 기기의 성능에 영향을 받는다.
  - SSR: 서버에서 렌더링을 담당한다. 비교적 안정적 렌더링이 가능하다.

### 장점

1. 최초 페이지 진입이 비교적 빠르다.

- SPA: 사용자가 페이지에 진입 -> JS 리소스 다운로드 -> HTTP 요청 수행 -> 응답 결과로 렌더링
- SSR: 서버에서 HTTP 요청을 수행하는 것이 더 빠르고, HTML 그리는 작업도 서버에서 미리 생성하는 것이 더 빠르다.
- 모든 SSR이 더 빠르다고는 할 수 없지만, 화면 렌더링이 HTTP 요청에 의존적이거나 렌더링할 HTML 크기가 커진다면 SSR이 더 빠를 수 있다.

2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.

- SSR은 검색 엔진 최적화(SEO)에 유리하다. 검색 엔진 로봇이 HTML만 다운로드하고 자바스크립트 코드는 실행하지 않기 때문이다.
- SPA는 대부분의 작동이 자바스크립트 코드에 의존하고, 페이지에 적합한 메타 데이터를 제공하기가 쉽지 않다.

3. 누적 레이아웃 이동(CLS)가 적다.

- CLS: 사용자에게 페이지를 보여준 이후에 HTML 정보가 추가되거나 삭제되어 화면 구조가 변경되는 부정적인 사용자 경험을 뜻한다.
- SPA는 모든 동적 컨텐츠가 API 요청에 의존적이어서 CLS가 발생할 수 있다. SSR은 요청이 완료된 이후에 완성된 페이지를 제공하기 때문에 덜 하다.
- SSR이 CLS 문제는 해결할지 몰라도, 모든 요청이 완료되기 전까지 페이지가 전혀 렌더링되지 않는다.
- 비동기 요청이 매우 오래 걸리는 경우, SPA는 CLS는 발생할지라도 화면의 구조는 렌더링이 되었는데 SSR은 블로킹 상태로 아무것도 렌더링이 되지 않았을 수 있다.
- 리액트 18에서의 스트림으로 해결?

4. 사용자의 디바이스 성능에서 비교적 자유롭다.

5. 보안에 좀 더 안전하다

- 자바스크립트 프로젝트의 문제점은 모든 활동이 브라우저에 노출된다는 것이다.
- SPA에서는 API 호출과 인증 같이 사용자에게 노출되면 안 되는 상황을 항상 방지해야 한다.
- SSR에서는 위와 같은 작업을 서버에서 수행하고 결과만 브라우저에 제공할 수 있기 때문에 보안에 조금 더 안전하다.

### 단점

1. 소스 코드를 작성할 때 항상 서버를 고려해야 한다.

- 코드가 서버에서 실행될 지? 클라이언트에서 실행될 지?를 고려해야 한다.
- 이에 따라 window, sessionStorage와 같이 브라우저에만 있는 전역 객체에 접근할 수도 못할 수도 있다.
- 외부에서 의존하고 있는 라이브러리에도 적용되기 때문에 사용할 때 고려해야 한다.

2. 적절한 서버가 구축돼 있어야 한다.

- SSR은 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하다.
- 서버를 구축하고 운영하는 것은 쉬운 일이 아니다: 물리적인 가용량, 장애 상황 대비, 복구 전략, 요청 분산

3. 서비스 지연에 따른 문제

- 서버 사이드 렌더링 도중 지연이 발생하면, 렌더링 작업이 끝나기 전까지는 사용자에게 그 어떤 정보도 제공할 수 없다.
- SPA에서는 로딩 중이라고 표시할 수 있는 반면, SSR은 그렇지 못하다.
- 병목 현상이 심해진다면, SSR이 오히려 더 SPA보다 안 좋은 사용자 경험을 제공할 수도 있다.

## SPA와 SSR을 모두 알아야 하는 이유

### 서버 사이드 렌더링 역시 만능이 아니다

- 성능을 해칠 뿐만 아니라 서버와 클라이언트로 관리 포인트가 늘어나 생산성이 더 하락할 수 있다.
- 웹 페이지의 목적, 설계, 우선순위에 따라 SPA? SSR?을 결정해야 한다.

### SPA와 SSR

1. 가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다.

- 어려워서 그렇지 최적화, 게으른 로딩, 코드 분할, 매끄러운 라우팅을 모두 달성한다면 가장 이상적이다.

2. 평균적인 싱글 페이지 애플리케이션은 평균적인 멀티 페이지 애플리케이션보다 느리다.

- 평균적인 노력을 기울여서 동일한 서비스를 만든다면, 서버에서 렌더링되는 멀티 페이지 애플리케이션이 더 우위에 있을 수 있다.
- 브라우저에 멀티 페이지 애플리케이션에서 발생하는 문제를 해결하기 위한 API가 추가되고 있다.
  - 페인트 홀딩: 같은 출처에서 라우팅이 발생할 경우, 하얀 화면 대신 이전 페이지를 잠시 보여주는 기법
  - back forward cache(bfcache): 브라우저 뒤로 / 앞으로 가기 실행 시 캐시된 페이지를 보여주는 기법
  - shared element transitions: 페이지 라우팅이 발생했을 때, 두 페이지에 공통적인 요소가 있다면 유지하여 부드럽게 전환되는 기법

### 현대의 서버 사이드 렌더링

- Next.js, Remix 등 서버 사이드 렌더링 프레임워크는 SSR과 SPA의 장점을 모두 활용한다.
- SSR은 초기에는 빠르지만, 이후 라우팅은 SPA보다 느리다는 단점이 있다.
- 현대 프레임워크는 최초에는 SSR을, 이후에는 서버로부터 추가로 받은 파일을 기반으로 CSR을 적용하여 더 나은 사용자 경험을 제공한다.

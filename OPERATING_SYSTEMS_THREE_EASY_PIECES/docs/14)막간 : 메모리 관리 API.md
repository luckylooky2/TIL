- Unix의 메모리 관리 인터페이스에 대해 논의한다
- 여기서의 메모리라 함은 사용자 주소 공간을 의미한다
- UNIX/C 프로그램에서 메모리를 할당하고 관리하는 방법을 이해한다

### 메모리 공간의 종류

- C 프로그램이 실행되면, 두 가지 유형의 메모리 공간이 할당된다
- **첫 번째는 스택(stack) 메모리**라고 불리며 할당과 반환은 프로그래머를 위해 컴파일러에 의해 암묵적으로 이루어진다
- 이러한 이유 때문에 때로는 자동(automatic) 메모리라고 불린다
- C 프로그램에서 스택에 메모리를 선언하는 것은 쉽다

```c
void	func() {
	int	x; // 스택에 int 형을 선언
}
```

- 컴파일러가 나머지 작업을 수행하여, `func()` 가 호출될 때 스택에 공간을 확보한다
- 함수에서 리턴하면 컴파일러는 프로그래머 대신에 메모리를 반환한다
- 함수 리턴 이후 에도 유지되어야 하는 정보는 스택에 저장하지 않는 것이 좋다
- 오랫동안 값이 유지되어야 하는 변수를 위해 **힙(heap) 메모리라고 불리는 두 번째 유형의 메모리**가 필요하다
- 모든 할당과 반환이 프로그래머에 의해 명시적으로 처리된다 무거운 책임이 아닐 수 없다!

```c
void	func() {
	int	*x = (int *) malloc(sizeof(int)); // 힙에 int 형 크기만큼의 메모리를 할당
}
```

- **첫째, 한 행에 스택과 힙 할당이 모두 발생한다**
- 우선 컴파일러가 포인터 변수의 선언(int \*x)을 만나면 정수 포인터를 위한 공간을 할당해야 한다는 것을 안다(스택)
- 프로그램이 `malloc()`을 호출하여 정수를 위한 공간을 힙으로부터 요구한다. `malloc()` 은 그 정수의 주소를 반환한다(성공한 경우, 실패한 경우에는 NULL을 반환)

### `malloc()` 함수

- 힙에 요청할 공간의 크기를 넘겨 주면, 성공했을 경우 새로 할당된 공간에 대한 포인터를 사용자에게 반환하고 실패했을 경우 NULL을 반환한다
- 이 정보로부터 malloc을 사용하기 위해서 할 일은 헤더 파일 stdlib.h를 소스 코드에 포함시키는 것 뿐이라는 것을 알 수 있다
- malloc() 의 인자는 size_t 타입의 변수이고 이 변수는 필요 공간의 크기를 바이트 단위로 표시한 것이다
- C 언어에서 이 sizeof() 는 통상 컴파일 시간 연산자이다. 인자의 실제 크기가 컴파일 시간에 결정된다. sizeof() 는 숫자(이 경우 double의 크기인 8)로 대체되어 malloc() 에 전달된다. 이러한 이유로, sizeof() 는 연산자로 간주되는 게 맞으며 함수 호출이 아니다(함수 호출은 실행 시간에 일어난다)

#### `sizeof()` 연산자

```c
int *x = malloc(10 * sizeof (int));
printf(“%d\n”, sizeof(x));
```

- sizeof()를 사용하면 4(32비트 컴퓨터에서) 또는 8(64비트 컴퓨터에서) 값이 반환한다
- 이 경우 sizeof() 는 동적으로 할당받은 메모리의 크기가 얼마인지가 아니라, 정수를 가리키는 포인터의 크기가 얼마인지 물어본다고 생각하기 때문이다

```c
int x[10];
printf(“%d\n”, sizeof(x));
```

- 그러나 때때로 sizeof() 는 기대한 대로 동작할 때도 있다
- 이 경우에는 변수 x에 40바이트가 할당되었다는 것을 컴파일러가 알 수 있는 정적인 정보가 충분하다

- **sizeof() 연산자는 컴파일 타임에 평가되며, 동적으로 할당된 메모리에 대한 크기를 알아낼 수 없다**
- sizeof()는 컴파일러가 컴파일 시간에 해당 변수 또는 타입의 크기를 결정할 수 있는 경우에만 사용 가능합니다
- 동적으로 할당된 메모리의 크기는 **런타임에 결정되기 때문에 sizeof()로 값을 얻을 수 없습니다**

- `malloc(strlen(s) + 1)` : 이 문장은 strlen() 함수를 사용하여 문자열의 길이를 얻어낸 뒤 문자열-끝을 나타내는 문자를 위한 공간을 확보하기 위해 1바이트를 더한다

- malloc() 은 void 타입에 대한 포인터를 반환한다는 것을 알았을 것이다
- 그렇게 하는 것은 **주소만 넘겨주고 해당 주소 공간에 어떤 타입의 자료를 저장할 지는 프로그래머가 결정하게 하는 전형적인 C의 방식이다**
- 프로그래머는 타입 변환(type casting)을 이용하여 공간 활용을 결정한다

### `free()` 함수

- “메모리 할당”은 우리가 고민하고 있는 문제들 중 쉬운 쪽이다
- *할당된 메모리를 언제, 어떻게 해제하고 더욱이 해제 여부를 확인*하는 것이 더 어려운 문제이다
- 더 이상 사용 되지 않는 힙 메모리를 해제하기 위해 프로그래머는 free() 를 호출한다
- 할당된 영역의 크기는 전달되지 않는다. 할당된 메모리의 크기는 메모리 할당 라이브러리가 알고 있어야 한다

### 흔한 오류

- C 프로그램은 컴파일하는 것만 중요한 것이 아니라, 올바른 메모리 관리도 중요하다
- 다른 언어들은 쓰레기 수집기라는 기능으로 자동 메모리 관리를 지원한다

#### 메모리 할당 잊어버리기

```c
char *src = “hello”;
char *dst; 			// 아뿔싸! 할당이 안되어 있네
strcpy (dst, src);	// segfault 그리고 죽는다
```

- 세그멘테이션 폴트(segmentation fault)가 발생할 가능성이 높다
- 이 폴트는 “네가 메모리 관련 무언가를 잘못했어, 이 바보 같은 프로그래머야. 그래서 나 화났거든”이라는 메시지이다.

#### 메모리를 부족하게 할당받기

```c
char *src = “hello”;
char *dst = (char *) malloc(strlen(src));	// 너무 작다!
strcpy (dst, src);							// 제대로 동작
```

- 메모리를 부족하게 할당받는 것으로, 때때로 버퍼 오버플로우(buffer over- flow)라고 불린다
- 어떤 경우에는 문자열 복사가 실행될 때 할당된 공간의 마지막을 지나쳐 한 바이트 만큼 더 공간을 사용한다. 이 공간이 더 이상 사용되지 않는 변수 영역이기 때문에 덮어쓰더라도 아무 피해가 발생하지 않을 때도 있다
- 다른 때에는 이러한 오버플로우가 매우 유해할 수 있고 사실 많은 시스템에서 보안 취약점의 원인이다
- 어떤 경우에는 malloc 함수 라이브러리가 여분의 공간을 할당하고 프로그램은 다른 변수의 값을 덮어쓰지 않고 잘 동작한다
- 또 다른 경우에는 프로그램은 고장을 일으키고 크래시된다
- **"즉, 프로그램이 한번 올바르게 실행된다고 하더라도, 프로그램이 올바르다는 것을 의미하지는 않는다"**

#### 할당받은 메모리 초기화하지 않기

- malloc () 을 제대로 호출했지만 새로 할당받은 데이터 타입에 특정 값을 넣는 것을 잊는 것이다.
- 절대로 이러지 마라. 초기화하지 않는다면, 프로그램은 결국 초기화되지 않은 읽기(uninitialized read), 즉 힙으로부터 알 수 없는 값을 읽는 일이 생긴다
- 임의의 값이나 해로운 값이 읽힐 것이다.

#### 메모리 해제하지 않기

- 메모리 누수(memory leak)다
- 장시간 실행되는 응용 프로그램이나 또는 운영체제 자체와 같은 시스템 프로그램 에서는 큰 문제이다
- 현대적인 언어에서도 메모리 누수는 여전히 문제가 된다
- 메모리 청크에 대한 참조가 존재하면, 어느 쓰레기 수집기도 그 청크를 해제하지 않을 것이기 때문이다
- **메모리 청크의 사용이 끝나면 반드시 해제해야 한다**
- 한 바이트라도 명시적으로 할당받았으면 해제하는 습관을 들이도록 하자

#### 메모리 사용이 끝나기 전에 메모리 해제하기

- 때때로 프로그램은 메모리 사용이 끝나기 전에 메모리를 해제한다. 그런 실수는 dangling pointer라고 불리며 심각한 실수이다
- 차후 그 포인터를 사용하면 프로그램을 크래시 시키거나 유효 메모리 영역을 덮어쓸 수 있다
- e.g. free()를 호출하고, 그 후 다른 용도로 malloc() 을 호출하면 잘못 해제된 메모리를 재사용한다

#### 반복적으로 메모리 해제하기

- 프로그램이 가끔씩 메모리를 한번 이상 해제하는 경우가 있다. 이를 이중 해제(double free)라고 한다
- 결과는 예측하기 어렵다
- 가장 흔히 일어나는 결과는 크래시다

#### `free()` 잘못 호출하기

- free() 는 malloc() 받은 포인터만 전달될 것으로 예상한다
- 그 이외의 값을 전달하면 문제가 발생한다
- 유효하지 않은 해제(invalid frees)는 매우 위험하고 당연히 피해야 한다

#### 여담 : 프로세스가 종료하면 왜 메모리 누수가 일어나지 않는가

- 시스템이 실제 두 단계로 메모리를 관리하기 때문이다
- 첫 번째 단계는 운영체제에 의해 수행된다. 프로세스가 실행할 때 메모리를 프로세스에게 건네 주고 프로세스가 종료하거나 다른 이유로 죽을 때 메모리를 되돌려 받는다
- 두 번째 단계는 각 프로세스 내에서, 예를 들면, malloc()과 free()를 호출할 때 힙 내에서 수행된다
- free() 를호출하지 못했더라도 그래서 메모리가 누수되었더라도 프로세스가 종료할 때, 운영체제는 프로세스의 모든 메모리를 회수한다
- *Web 서버*나 _데이터베이스 관리 시스템_ 등의 결코 종료하지 않는 장시간 실행되는 서버 (웹서버나 데이터베이스 관리 시스템과 같이 절대 종료하지 않는 것)의 코드를 작성할 때, 누수 메모리는 훨씬 심각한 문제이고 응용 프로그램이 메모리를 다 소진하게 되면 결국 크래시가 발생한다

### 운영체제의 지원

- malloc()과 free()를 논의해 오면서 시스템 콜에 관해서는 한번도 언급하지 않았다. 이유는 간단하다: _그들은 시스템 콜이 아니라 라이브러리 함수이기 때문이다_
- malloc() 은 여러 최적화와 다양한 알고리즘을 사용하여 메모리를 효율적으로 관리합니다
- 만약 프로그래머가 `brk()`, `mmap()` 등의 메모리 할당 시스템 콜을 직접 호출한다면 더 복잡하고 낮은 수준의 인터페이스를 다뤄야 하게 됩니다
- malloc()은 _프로세스 가상 주소 공간 안의 공간을 관리하는 기능까지 하기 때문에_ **시스템 콜 그 자체가 아니다!**
- `brk()`
  - 프로그램의 break 위치를 변경하는 데 사용된다
  - <U>break는 힙의 마지막 위치를 나타낸다</U>
  - brk는 새로운 break 주소를 나타내는 한 개의 인자를 받는다
  - 새로운 break가 현재 break보다 큰지 작은 지에 따라 힙의 크기를 증가시키거나 감소시킨다
  - sbrk는 증가량만을 받아들이는 것을 제외하고 비슷한 용도로 사용된다
- `brk()` 또는 `sbrk()`를 직접 호출해서는 안 된다는 것에 주의하라. 직접 사용하면 감당할 수 없는 결과가 발생할 것이다
- `mmap()`
  - 올바른 인자를 전달하면 mmap () 은 프로그램에 anonymous의 메모리 영역을 만든다
  - anonymous 영역은 특정 파일과 연결되어 있지 않고 스왑 공간(swap space) 에 연결 된 영역을 말한다
  - 이 메모리는 힙처럼 취급되고 관리된다

### 숙제

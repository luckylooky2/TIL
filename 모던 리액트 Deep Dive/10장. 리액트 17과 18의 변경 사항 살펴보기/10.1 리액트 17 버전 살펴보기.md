# 9.1 리액트 17 버전 살펴보기

- 리액트 애플리케이션의 버전 점유율: 0(12%), 15(21%), 16(55%), 17(12%)
- 가장 대표적인 애플리케이션 airbnb, netflix도 리액트 16 버전을 사용하고 있다(2022년 8월 기준).
- 16 버전만으로도 충분히 사용자에게 뛰어난 경험을 제공할 수 있지만, 최신 버전에서는 더 나은 기능을 가볍고 빠르게 제공해주는 장점이 있기 때문에 사용해볼 만하다.
- 또한 사용하는 라이브러리의 peerDependencies를 충족하기 위해서라도 최신 버전을 사용해야 할 수 있다.

- 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없다.
- 즉, 호환성이 깨지는 변경 사항을 최소화했다는 점이 가장 큰 특징이다.
- 16 버전 애플리케이션은 부담 없이 17 버전으로 업그레이드할 수 있다.

## 1. 리액트의 점진적인 업그레이드

- 유의적 버전 전략에 의하면, Major 버전이 올라갈 때는 호환성이 깨지는 변경 사항이 있다.
- 하지만 리액트 17 버전부터는 점진적인 업그레이드를 지원한다.
- 예를 들어, 리액트 18을 사용하면서도 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능하다.
- 관리 포인트가 늘어나는 것이 단점이지만, 버전 변화에 유연하게 대응할 수 있다는 장점이 있다.
- 하나의 애플리케이션에서 하위 버전(e.g. 16)을 위한 별도의 루트 요소를 만들고, 불러온 하위 버전(e.g. 16) 리액트 모듈을 렌더링하는 구조로 함께 사용할 수 있다.
- 결과적으로 버전 불일치로 인한 에러가 발생하지 않고, 하나의 웹 사이트에서 두 개의 리액트가 존재하는 것이 가능하다.
- Context가 제공하는 값도 마찬가지로 동일하게 사용할 수 있다.
- 이 접근 방식은 어디까지나 임시적인 방법이며, 버전 업그레이드를 위한 준비 단계로 사용하는 것이 좋다.

## 2. 이벤트 위임 방식의 변경

### 이벤트 핸들러를 처리하는 방식

- 아래 두 방식은 겉으로는 똑같이 해당 요소의 이벤트 리스너에 이벤트 핸들러를 등록하는 것처럼 보인다.
  - addEventListener: 해당 요소의 이벤트 리스너에 이벤트 핸들러를 등록한다.
  - 리액트: 위와 달리, 모든 이벤트 핸들러를 루트 요소의 이벤트 리스너에 부착하는데 이를 이벤트 위임이라고 한다.
- 이벤트 위임이란, 이벤트 단계의 원리(캡처링 -> 타겟 -> 버블링)를 이용해 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다.
- 리액트는 16 버전까지 각각의 이벤트 핸들러를 document 객체에 위임해서 이벤트를 조금 더 효율적으로 관리했다.
- 하지만 리액트 17 버전부터는 리액트 컴포넌트 최상단 트리(루트 요소)로 이벤트를 위임한다.
- 장점: 확장성 증가, 효율적인 관리 가능

### 리액트에서 이벤트 핸들러를 처리하는 과정

- 1. 브라우저에서는 해당 요소에 이벤트 리스너가 존재하지 않기 때문에, 특정 이벤트가 발생하면 이벤트 버블링을 통해 리액트가 **이벤트 위임**을 통해 루트 요소(#root) 또는 document에 부착한 이벤트 리스너를 찾는다 => 브라우저 네이티브 이벤트 위임
- 2. 리액트는 브라우저에서 발생한 네이티브 이벤트를 루트 요소(#root) 또는 document 에서 가로챈다.
- 3. 리액트는 네이티브 이벤트를 추상화된 SyntheticEvent로 변환하여 독자적인 합성 이벤트 전파 시스템에서 사용한다.
  - SyntheticEvent: 브라우저 간의 차이를 감추고 일관된 API를 제공, SyntheticEvent 객체를 재사용하여 메모리를 절약(풀링된 이벤트 시스템)
- 4. 리액트는 DOM 트리와 동일한 구조를 기준으로 합성 이벤트를 캡처링 → 타겟 → 버블링 순서로 전파한다.

- 네이티브 이벤트 전파 단계와 리액트 합성 이벤트 전파 단계는 독립적이다.
  - 리액트 16 버전에서는 document와 root 사이에서 `e.stopPropagation()`을 호출하면 네이티브 이벤트 전파 단계가 중단되므로 리액트의 모든 핸들러가 동작하지 않게 된다.
  - 리액트 17 버전에서는 루트 요소로 이벤트를 위임하므로, 리액트의 모든 핸들러의 동작이 보장된다.
- addEventListener 이벤트 핸들러에서의 이벤트 객체(PointerEvent)와 리액트 이벤트 핸들러에서의 이벤트 객체(SyntheticEvent)는 다르다.
- 리액트는 자체 이벤트 시스템을 가지고 있어서, 네이티브 DOM 이벤트를 직접 실행하지 않습니다. 대신, 리액트는 이벤트 위임을 사용하여 최상위 요소에서 이벤트를 처리합니다. 리액트의 이벤트 시스템은 document나 root 요소에 이벤트 리스너를 추가하고, 이벤트가 발생하면 이를 캡처하여 리액트의 이벤트 시스템(SyntheticEvent 및 Fiber tree)으로 전달합니다.

- Q) 브라우저 네이티브 이벤트 캡처링/버블링 단계와 React 이벤트 캡처링/버블링 단계는 원래부터 구분되어 있었는가? A) React는 브라우저의 네이티브 이벤트를 루트 컨테이너(#root 또는 document)에서 가로챈 뒤, 자체적인 합성 이벤트 시스템을 사용해 별도로 캡처링/버블링 단계를 처리한다.
- Q) 브라우저 네이티브 이벤트는 document로 위임하는데만 쓰이고, 실질적으로 이벤트 버블링을 처리하는 것은 React 내부 구현인가? React는 브라우저 네이티브 이벤트를 단순히 루트 컨테이너에서 한 번만 감지하고, 이후 이벤트 버블링/캡처링 전파는 React 내부 시스템에서 구현한다. 네이티브 이벤트는 React의 합성 이벤트 시스템을 시작하는 트리거 역할만 할 뿐이다.

- 리액트 17 버전에서는 이벤트 위임 위치가 루트 요소로 변경하여, 리액트 컴포넌트 트리 수준으로 격리하였다. 덕분에 이벤트 전파가 독립적으로 동작하게 되어, 예측이 가능하고 안정적인 이벤트 핸들링이 가능해졌다.

### `stopPropagation()`

- 리액트 16 버전
  - 모든 이벤트가 최상위 DOM 요소(document)에 위임된다.
  - 네이티브 이벤트는 이미 document까지 전파되었기 때문에 document에 있는 네이티브 DOM 이벤트 핸들러(addEventListener)는 계속 실행된다.
  - SyntheticEvent.stopPropagation()은 리액트 내부의 이벤트 핸들러 전파만 중단시킨다.
- 리액트 17 버전
  - 모든 이벤트가 리액트 트리의 루트 노드로 위임된다.
  - SyntheticEvent.stopPropagation()는 React 트리 내에서의 전파가 중단시키고, 네이티브 DOM 이벤트도 루트 컨테이너를 넘어서 전파되지 않는다.
  - 즉, React 트리의 루트 컨테이너와 document 간의 이벤트 전파가 자연스럽게 동기화되며, 루트에서 전파를 중단하면 document에도 영향을 미친다고 할 수 있다.

[](./eventDelegation/eventDelegation.js)
[SyntheticEvent 생성 및 이벤트 처리 과정](https://blog.mathpresso.com/react-deep-dive-react-event-system-1-759523d90341)

## 3. import React from 'react'가 더 이상 필요 없다: 새로운 JSX transform

- 이전 버전까지는 JSX를 사용하기 위해 `import React from 'react'`를 반드시 선언해야 했다.
- JSX가 변환될 때, React.createElement 함수를 호출하기 때문이다.
- 17 버전에서는 React.createElement가 아닌 react/jsx-runtime의 \_jsxRuntime을 사용하여 JSX를 변환한다.
- require()을 사용하므로 import React from 'react'를 선언하지 않아도 된다.
- 장점: jsx-runtime은 React.createElement보다 더 작고 빠르다. 불필요한 코드를 줄여줘서 번들 크기를 줄일 수 있다.

## 4. 이벤트 풀링 제거

- 리액트에서는 NativeEvent를 SyntheticEvent로 변환하여 이벤트를 처리한다.
- 이벤트를 만들 때마다 메모리 할당 작업이 일어나고, 메모리를 주기적으로 해제해야 하는 번거로움이 있었다.
- 이벤트 풀링: SyntheticEvent 객체 생성에 소요되는 시간을 줄이기 위해 SyntheticEvent Pool을 만들어서 이벤트가 발생할 때 가져올 수 있게 하였다.
- 과정
  1. 이벤트 핸들러가 이벤트를 발생시킨다.
  2. 합성 이벤트 풀에서 합성 이벤트 객체의 참조를 가져온다.
  3. 이벤트 정보를 합성 이벤트 객체에 넣어준다.
  4. 유저가 지정한 이벤트 리스너가 실행된다.
  5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.
- 효과적인 방법처럼 보이지만, 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 null로 초기화하는 방식은 사용하는 쪽에서 직관적이지 않다.
- SyntheticEvent는 이벤트 핸들러 실행이 끝난 직후에 초기화된다. 이로 인해 비동기 코드 내부에서 SyntheticEvent 객체에 접근하려고 하면 이미 초기화된 상태이다.
- 비동기 코드 내부에서 이 합성 이벤트 e에 접근하기 위해서는 추가적인 작업인 e.persise()를 호출해야 했다. e.persist()를 호출하면 SyntheticEvent 객체가 이벤트 풀로 반환되지 않고, 초기화되지 않는다.
- SyntheticEvent를 풀링하여 얻는 성능 이점보다, 이를 관리하는 데 따른 복잡성이 더 큰 부담으로 작용했기 때문에 이벤트 풀링 기능을 제거하였다.

## 5. useEffect 클린업 함수의 비동기 실행

- 16 버전까지 useEffect의 클린업 함수는 동기적으로 실행되었기 때문에 불필요한 성능 저하가 발생할 수 있었다.
- 17 버전부터는 화면이 완전히 업데이트된 이후(커밋 단계가 완료된 이후)에 클린업 함수가 비동기적으로 실행되어 약간의 성능 향상을 가져왔다.
- Profiler 컴포넌트를 가지고 커밋 단계를 측정해보았을 때, 17 버전의 useEffect의 클린업 함수가 커밋 단계 이후에 실행되는 것을 확인할 수 있다.

## 6. 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16과 17 버전은 컴포넌트에서 undefined를 반환하면 오류가 발생한다. 의도치 않은 반환으로 인한 실수를 방지하기 위해서이다.
- 리액트 16 버전에서는 forwardRef나 memo에서 undefined를 반환하면 오류가 발생하지 않았다. 17 버전에서는 정상적으로 에러가 발생한ㄷ.
- 리액트 18 부터는 undefined를 반환해도 에러가 발생하지 않는다. 리액트 18부터는 컴포넌트가 undefined를 반환할 경우, null로 처리되어 렌더링 결과가 화면에 아무것도 표시되지 않도록 되었다.

## 정리

- 리액트 17 버전은 호환성을 깨지 않는 변경 사항을 최소화하고, 점진적인 업그레이드를 지원하는데 초점을 맞추었다.

- **멀티 레벨 피드백 큐(Multi-level Feedback Queue, MLFQ) 스케줄러**는 Compatible Time-Sharing System(CTSS) 에 사용되 며 Corbato 등에 의 해 1962 년에 최초로 소개되었다
- MLFQ가 해결하려고 하는 기본적인 문제는 두 가지이다
  - 첫째, 짧은 작업을 먼저 실행시켜 반환 시간을 최적화하고자 한다
  - 둘째, MLFQ는 대화형 사용자(즉, 화면 앞에 앉아 바라보면서 프로세스의 종료를 기다리는 사용자) 에게 응답이 빠른 시스템이라는 느낌을 주고 싶었기 때문에 응답 시간을 최적화한다
- SJF나 STCF 같은 알고리즘은 작업의 실행 시간 정보를 필요로 하지만, 불행히도 운영 체제는 이 실행 시간을 미리 알 수 없다. 또한 RR과 같은 알고리즘은 응답 시간을 단축시키지만 반환 시간은 거의 최악이다
- **작업의 실행 시간에 대한 선행 정보 없이 대화형 작업의 응답 시간을 최소화하고 동시에 반환 시간을 최소화하는 스케줄러를 어떻게 설계할 수 있는가?**

### MLFQ: 기본 규칙

- MLFQ는 **1) 여러 개의 큐**로 구성되며, **2) 각각 다른 우선순위(priority level)**가 배정된다
- MLFQ는 실행할 프로세스를 결정하기 위하여 우선순위를 사용한다. 높은 우선순위를 가진 작업이, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다
- 하나의 큐에는 둘 이상의 작업이 존재할 수 있다. 이들은 모두 같은 우선순위를 가진다. 이 작업들 사이에서는 라운드 로빈(Round-Robin, RR) 스케줄링 알고리즘이 사용된다
- MLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아니라 **각 작업의 특성에 따라 동적으로 우선순위를 부여**한다
  - e.g.
  - 어떤 작업이 키보드 입력을 기다리며 _반복적으로 CPU를 양보하면_ MLFQ는 해당 작업의 _우선순위를 높게 유지한다_
  - 한 작업이 _긴 시간 동안 CPU를 집중적으로 사용하면_ MLFQ는 해당 작업의 _우선순위를 낮춘다_
- MLFQ는 작업이 진행되는 동안 해당 작업의 정보를 얻고, 이 정보를 이용하여 미래 행동을 예측한다

> 규칙 1: Priority(A) > Priority(B) 이면, A가 실행된다 (B는 실행되지 않는다)

> 규칙 2: Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행된다

!["8-1"](8-1.png)

- MLFQ의 동작을 고려하면 스케줄러는 가장 높은 우선순위의 큐의 A와 B를 번갈아 실행할 것이다
- 불쌍한 작업 C와 D는 실행되지도 않는다
- 정적인 하나의 스냅 사진만으로는 MLFQ가 어떻게 동작하는지 알 수 없다
- 규칙 1과 2에는 작업의 우선순위가 어떻게 바뀔지에 대한 내용은 나와있지 않다
- 작업 우선순위가 **시간에 따라** 어떻게 변화하는지 알아보자

### 시도 1 : 우선순위의 변경

- 작업의 우선순위를 변경하는 것은 작업이 존재할 큐를 결정하는 것과 마찬가지다
- 우선순위를 변경하기 위해 워크로드의 특성을 반영해야 한다
- 작업들 중에는

  - **짧은 실행 시간을 갖는 CPU를 자주 양보하는 대화형 작업**과
  - **많은 CPU 시간을 요구하지만 응답 시간은 중요하지 않은 긴 실행 시간의 CPU 위주 작업**이
  - 혼재되어 있다

> 규칙 3: 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다

> 규칙 4a: 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다. 즉, 한 단계 아래 큐로 이동한다

> 규칙 4b: 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지한다

- 스케줄러는 작업이 짧은 작업인지 긴 작업인지 알 수 없기 때문에 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여한다
- 규칙 4a에 의해 짧은 작업이면 빨리 실행되고 종료되고, 짧은 작업이 아니라면 우선순위가 가장 낮은 큐로 가게된다
- 다시 말해서, 진짜 짧은 작업이면 빨리 실행되고 바로 종료할 것이다. 짧은 작업이 아니라면 천천히 아래 큐로 이동하게 되고 스스로 긴 배치형 작업이라는 것을 증명하게 된다
- **이러한 방식으로 MLFQ는 SJF를 근사할 수 있다**
- 즉, 짧은 작업인지를 알 수는 없지만, 위와 같은 규칙에 의해 짧은 작업을 먼저 실행하는 SJF와 비슷하다고 할 수 있다(반환 시간을 줄인다)

!["8-2"](8-2.png)
!["8-3"](8-3.png)

- 검정색은 오래 실행되는 CPU 위주(배치형) 작업, 회색은 짧은 대화형 작업이다

- 규칙 4b가 말하는 것처럼, 프로세스가 타임 슬라이스를 소진하기 전에 프로세서를 양도하면 같은 우선순위를 유지하게 한다
- 즉, 대화형 작업이 키보드나 마우스로부터 사용자 입력을 대기하며 자주 입출력을 수행하면 타임 슬라이스가 종료되기 전에 CPU를 양도하게 될 것이다

!["8-4"](8-4.png)

- 짧은 대화형 작업(회색)은 타임 슬라이스를 모두 소진하기 전에 CPU를 계속해서 양도하기 때문에 MLFQ 방식은 B를 가장 높은 우선순위로 유지한다
- 대화형 작업을 빨리 실행시킨다는 목표에 근접하게 된다(응답 시간을 줄인다)
- 반면, 긴 CPU 위주 작업(검정색)은 낮은 우선순위인 채로 대화형 작업이 끝나기를 기다리고 있다

- 하지만 이 방법은 심각한 결점을 갖는다
  1.  기아(starvation) 상태가 발생할 수 있다
      - 시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU 시간을 소모하게 될 것이고
      - 따라서 긴 실행 시간 작업은 CPU 시간을 할당받지 못하는 문제가 발생할 수 있다
      - 긴 배치형 작업도 실행에서 아예 배제되는 것이 아니라 같이 진행이 되도록 만들어야 한다
  2.  CPU를 거의 독점하는 애플리케이션을 만들 수 있다
      - 타임 슬라이스가 끝나기 전에 아무 파일을 대상으로 입출력 요청을 내려 CPU를 양도한다
      - 그렇게 하면 같은 큐에 머무를 수 있고 따라서 더 높은 퍼센트의 CPU 시간을 얻게 된다
      - 제대로 된다면, 예를 들어 타임 슬라이스의 99%를 실행하고 CPU를 양도하게 되면 CPU를 거 의 독점할 수 있다
  3.  시간 흐름에 따라 특성이 변할 수 있다
  - CPU 위주 작업이 대화형 작업으로 바뀔 수 있다
  - 반대로, 대화형 작업이 CPU 위주 작업으로 바뀔 수도 있다
  - 현재 구현 방식으로는 그런 작업은 운이 없게도 다른 대화형 작업들과 같은 대우를 받을 수 없다

### 시도 2 : 우선순위의 상향 조정

- 규칙을 보완하여 기아 문제를 방지할 수 있는지 살펴보자
- 주기적으로 모든 작업의 우선순위를 상향 조정(boost)하여 CPU 위주 작업이 조금이라도 진행하는 것을 보장할 수 있다

> 규칙 5: 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다

- 규칙 5는 1, 3번 문제를 해결한다
- 첫째, 최상위 큐에 존재하는 동안 작업은 다른 높은 우선순위 작업들과 라운드 로빈 방식으로 CPU를 공유하게 되고 서비스를 받게 된다
- 둘째, CPU 위주의 작업이 대화형 작업으로 특성이 변할 경우 우선순위 상향을 통해 스케줄러가 변경된 특성에 적합한 스케줄링 방법을 적용한다
- 일정 기간 S는 얼마가 되어야 하는가?
- 부두 상수(voo-doo constants) : 너무 크면 긴 실행 시간을 가진 작업은 굶을 수 있으며 너무 작으면 대화형 작업이 적절한 양의 CPU 시간을 사용할 수 없게 된다

!["8-5"](8-5.png)

- 우선순위 상향(boost)가 없는 왼쪽 그림은, 긴 실행 시간 작업은 두 개의 짧은 작업이 도착한 이후에는 굶게 된다
- 우선순위 상향(boost)가 있는 오른쪽 그림은, 긴 실행 시간 작업도 꾸준히 진행된다는 것을 보장할 수 있으며, 50 msec 마다 상향되고 따라서 주기적으로 실행된다

### 시도 3 : 더 나은 시간 측정

- 아직 문제 2를 해결하지 못하였다. 스케줄러를 자신의 실행 프로그램에게 유리하게 동작하는 것을 어떻게 막을 수 있는가?
- 이러한 일을 가능하게 만든 주범은 규칙 4a와 4b이다
- 즉, 타임 슬라이스가 끝나기 전에 CPU를 양보하여 우선 순위를 유지가 가능하게 한다
- **해결책은 MLFQ의 각 단계에서 CPU 총 사용 시간을 측정하는 것이다**
- 즉, CPU 사용 시간을 누적하여 독점적으로 반복하여 사용하는 것을 막는다. 한 번의 CPU 사용마다 사용 시간이 초기화되지 않고 누적된 시간을 채우면 다음 우선순위 큐로 강등된다

> 규칙 4: 주어진 단계에서 시간 할당량을 소진하면 (CPU를 몇 번 양도하였는지 상관 없이), 우선순위는 낮아진다 (즉, 아래 단계의 큐로 이동한다).

!["8-6"](8-6.png)

- 조작에 대한 내성이 없는 왼쪽 그림은 짧은 대화형 작업(회색)이 CPU 사용 시간을 계속 초기화하며 최상위 우선순위 큐를 유지하고 있다. 이 때문에 긴 CPU 위주의 작업(검정색)은 실행되지 못한다
- 조작에 대한 내성이 있는 오른쪽 그림은 짧은 대화형 작업(회색)이 사용하는 CPU 사용 시간이 사용 횟수와 관계없이 누적되기 때문에 최상위 우선순위 큐를 계속하여 유지할 수 없다

> 규칙 1: Priority(A) > Priority(B) 이면, A가 실행된다 (B는 실행되지 않는다)

> 규칙 2: Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행된다

> 규칙 3: 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다

> 규칙 4: 주어진 단계에서 시간 할당량을 소진하면 (CPU를 몇 번 양도하였는지 상관 없이), 우선순위는 낮아진다 (즉, 아래 단계의 큐로 이동한다).

> 규칙 5: 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다

### MLFQ 조정과 다른 쟁점들

- 적절한 변수 값을 설정해야 한다
  - 몇 개의 큐?
  - 큐당 타임 슬라이스의 크기?
  - 얼마나 자주 우선순위가 상향 조정되어야 하는가?
- 정답이 존재하지 않기 때문에, 워크로드에 대해 충분히 경험하고 계속 조정해 나가면서 균형점을 찾아야 한다
- 대부분의 MLFQ 기법들은 큐 별로 타임 슬라이스를 변경할 수 있다. **우선순위가 높은 큐는 보통 짧은 타임 슬라이스가 주어진다**
  - 높은 우선순위 : 대화형 작업들로 구성, 10ms 이하
  - 낮은 우선순위 : CPU 위주 작업들로 구성, 수백ms 이상
- Solaris
  - 프로세스의 우선순위가 일생 동안 어떻게 변하는지, 타임 슬라이스의 길이는 얼마인지, 작업의 우선순위는 얼마나 자주 상향되는지를 결정하는 테이블을 제공한다
  - 관리자는 이 테이블을 수정하여 스케줄러의 동작 방식을 바꿀 수 있다
  - 기본 설정 값 : 큐(60개), 타임 슬라이스 크기(20ms ~ 수백ms), 우선순위 상향 조정 주기(1초)
- FreeBSD
  - 작업의 현재 우선순위를 계산하기 위하여 프로세스가 사용한 CPU 시간을 기초로 한 공식을 사용한다
  - CPU 사용은 시간이 지남에 따라 감쇠되어 이 장에서 설명한 방식과는 다른 방식으로 우선순위 상향을 제공한다(감쇠-사용(decay-usage) 알고리즘)
- 일부 스케줄러

  - 가장 높은 우선순위를 운영체제 작업을 위해 예약해 둔다
  - 일반적인 사용자 작업은 시스템 내에서 가장 높은 우선순위를 얻을 수 없다
  - `nice` 명령어로 작업의 우선순위를 조절할 수 있다

### 요약

- Multi-level Feedback Queue

  - Multi-level Queue : 여러 개의 우선순위 큐
  - Feedback : 지정된 작업의 우선순위를 정하기 위하여 피드백을 사용(과거에 보여준 행동이 우선순위 지정의 지침이 된다)

- 특징
  - 작업의 특성에 대한 정보 없이, 작업의 실행을 관찰한 후 그에 따라 우선순위를 지정한다
  - 반환 시간과 응답 시간을 모두 최적화한다
  - 짧게 실행되는 대화형 작업에 대해서는 우수한 전반적인 성능을 제공한다(SJF/ STCF와 유사)
  - 오래 실행되는 CPU-집중 워크로드에 대해서는 공정하게 실행하고 조금이라도 진행되도록 한다

### 숙제

#### 1. 두 개의 작업과 두 개의 큐를 무작위로 구성하여 실행시켜 보시오. 각 문제에 대한 MLFQ 실행 추적을 계산하시오. 문제를 쉽게 하기 위해 각 작업의 길이를 제한하고 입출력은 하지 않는다고 가정하시오

```shell
$> python mlfq.py --numJobs=2 --numQueues=2 --maxlen=10 --maxio=0 --quantum=1 -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 2
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   1
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   1
OPTIONS boost 0
OPTIONS ioTime 5
OPTIONS stayAfterIO False
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime   8 - ioFreq   0
  Job  1: startTime   0 - runTime   4 - ioFreq   0


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] JOB BEGINS by JOB 1
[ time 0 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 7 (of 8) ]
[ time 1 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 3 (of 4) ]
[ time 2 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 6 (of 8) ]
[ time 3 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 2 (of 4) ]
[ time 4 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 5 (of 8) ]
[ time 5 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 1 (of 4) ]
[ time 6 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 8) ]
[ time 7 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 4) ]
[ time 8 ] FINISHED JOB 1
[ time 8 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 3 (of 8) ]
[ time 9 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 2 (of 8) ]
[ time 10 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 1 (of 8) ]
[ time 11 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 8) ]
[ time 12 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  12
  Job  1: startTime   0 - response   1 - turnaround   8

  Avg  1: startTime n/a - response 0.50 - turnaround 10.00
```

- 타임 슬라이스(quantum)가 지날 때마다 job을 번갈아가며 실행한다 : `--quantum=1`
- 타임 슬라이스가 지날 때마다 우선순위 큐가 한 단계씩 낮아진다
- I/O 작업은 따로 없다고 가정한다 : `--maxio=0`
- time 8에 JOB 1(4)이 종료되고, time 12에 JOB 0(8)이 종료된다

#### 2. 이 장의 예제를 재현하려면 스케줄러를 어떻게 실행해야 하는가?

##### 예 1: 한 개의 긴 실행 시간을 가진 작업

!["8-2"](8-2.png)

```shell
$> python mlfq.py --numjobs=1 --numQueues=3 --maxlen=10 --maxio=0 --quantum=1 -c
Here is the list of inputs:
OPTIONS jobs 1
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   1
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   1
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   1
OPTIONS boost 0
OPTIONS ioTime 5
OPTIONS stayAfterIO False
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime   8 - ioFreq   0


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 7 (of 8) ]
[ time 1 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 6 (of 8) ]
[ time 2 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 5 (of 8) ]
[ time 3 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 8) ]
[ time 4 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 3 (of 8) ]
[ time 5 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 2 (of 8) ]
[ time 6 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 1 (of 8) ]
[ time 7 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 8) ]
[ time 8 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround   8

  Avg  0: startTime n/a - response 0.00 - turnaround 8.00
```

- 3개의 우선순위 큐에서 타임 슬라이스가 지날 때마다 한 단계씩 하락한다 : `--numjobs=1 --numQueues=3`

##### 예 2: 짧은 작업과 함께

!["8-3"](8-3.png)

```shell
$> python mlfq.py --jlist=0,10,0:5,2,0 --numQueues=3 --quantum=1 -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   1
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   1
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   1
OPTIONS boost 0
OPTIONS ioTime 5
OPTIONS stayAfterIO False
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  10 - ioFreq   0
  Job  1: startTime   5 - runTime   2 - ioFreq   0


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 9 (of 10) ]
[ time 1 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 8 (of 10) ]
[ time 2 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 7 (of 10) ]
[ time 3 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 6 (of 10) ]
[ time 4 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 5 (of 10) ]
[ time 5 ] JOB BEGINS by JOB 1
[ time 5 ] Run JOB 1 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 1 (of 2) ]
[ time 6 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 0 (of 2) ]
[ time 7 ] FINISHED JOB 1
[ time 7 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 10) ]
[ time 8 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 3 (of 10) ]
[ time 9 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 2 (of 10) ]
[ time 10 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 1 (of 10) ]
[ time 11 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 10) ]
[ time 12 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  12
  Job  1: startTime   5 - response   0 - turnaround   2

  Avg  1: startTime n/a - response 0.00 - turnaround 7.00
```

- `--jlist=0,10,0:5,2,0` : time 0에 시작하여 10동안 실행하고 0초마다 I/O 작업을 실행하는 작업 1개, time 5에 시작하여 2동안 실행하고 0초마다 I/O 작업을 실행하는 작업 1개
- CPU 위주 긴 작업(JOB 0)이 먼저 시작되고, 여러 번의 타임 슬라이스를 거쳐 PRIORITY 0로 이동한다
- 중간에 짧은 대화형 작업(JOB 1)이 도착한다. 대화형 작업(JOB 1)은 PRIORITY 2에 추가되므로 먼저 시작되고, 긴 작업(JOB 0)은 아직 PRIORITY 0에 존재하므로 실행되지 않는다. 즉, SJF와 비슷하게 동작한다
- 대화형 작업(JOB 1)이 PRIORITY 0으로 내려오면 비로소 두 작업이 번갈아가며 실행된다

##### 예 3: 입출력-집중 작업과 CPU-집중 작업이 혼합된 워크로드

!["8-4"](8-4.png)

```shell
$> python mlfq.py --jlist=0,10,1:0,10,0 --numQueues=3 --quantum=2 --stay --iotime=1 -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   2
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   2
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   2
OPTIONS boost 0
OPTIONS ioTime 1
OPTIONS stayAfterIO True
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  10 - ioFreq   1
  Job  1: startTime   0 - runTime  10 - ioFreq   0


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] JOB BEGINS by JOB 1
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 9 (of 10) ]
[ time 1 ] IO_START by JOB 0
IO DONE
[ time 1 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 9 (of 10) ]
[ time 2 ] IO_DONE by JOB 0
[ time 2 ] Run JOB 1 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 8 (of 10) ]
[ time 3 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 8 (of 10) ]
[ time 4 ] IO_START by JOB 0
IO DONE
[ time 4 ] Run JOB 1 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 7 (of 10) ]
[ time 5 ] IO_DONE by JOB 0
[ time 5 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 7 (of 10) ]
[ time 6 ] IO_START by JOB 0
IO DONE
[ time 6 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 6 (of 10) ]
[ time 7 ] IO_DONE by JOB 0
[ time 7 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 6 (of 10) ]
[ time 8 ] IO_START by JOB 0
IO DONE
[ time 8 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 10) ]
[ time 9 ] IO_DONE by JOB 0
[ time 9 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 5 (of 10) ]
[ time 10 ] IO_START by JOB 0
IO DONE
[ time 10 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 10) ]
[ time 11 ] IO_DONE by JOB 0
[ time 11 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 4 (of 10) ]
[ time 12 ] IO_START by JOB 0
IO DONE
[ time 12 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 3 (of 10) ]
[ time 13 ] IO_DONE by JOB 0
[ time 13 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 3 (of 10) ]
[ time 14 ] IO_START by JOB 0
IO DONE
[ time 14 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 2 (of 10) ]
[ time 15 ] IO_DONE by JOB 0
[ time 15 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 2 (of 10) ]
[ time 16 ] IO_START by JOB 0
IO DONE
[ time 16 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 10) ]
[ time 17 ] IO_DONE by JOB 0
[ time 17 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 1 (of 10) ]
[ time 18 ] IO_START by JOB 0
IO DONE
[ time 18 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 10) ]
[ time 19 ] FINISHED JOB 1
[ time 19 ] IO_DONE by JOB 0
[ time 19 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 0 (of 10) ]
[ time 20 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  20
  Job  1: startTime   0 - response   1 - turnaround  19

  Avg  1: startTime n/a - response 0.50 - turnaround 19.50
```

- CPU 위주 긴 작업(JOB 1)은 여러 번의 타임 슬라이스(2)를 거쳐 PRIORITY 0로 이동한다
- 짧은 대화형 작업(JOB 0)은 규칙 4b에 의해 타임 슬라이스(2)를 소진하기 전에 (1초마다) I/O 작업이 실행되어 프로세스를 양도하므로 PRIORITY 2를 유지한다 : `--jlist=0,10,1:0,10,0 --iotime=1`
- 짧은 대화형 작업(JOB 0)이 프로세스를 양도할 때마다, PRIORITY 0에 있더라도 CPU 위주 긴 작업(JOB 1)은 실행될 수 있다

##### 예 4: 너무 많은 대화형 작업이 존재한다면?

!["8-5"](8-5.png)

```shell
$> python mlfq.py --jlist=0,10,0:5,5,1:6,5,1 --numQueues=3 --quantum=2 --stay --iotime=1 -c
Here is the list of inputs:
OPTIONS jobs 3
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   2
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   2
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   2
OPTIONS boost 0
OPTIONS ioTime 1
OPTIONS stayAfterIO True
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  10 - ioFreq   0
  Job  1: startTime   5 - runTime   5 - ioFreq   1
  Job  2: startTime   6 - runTime   5 - ioFreq   1


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 9 (of 10) ]
[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 8 (of 10) ]
[ time 2 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 7 (of 10) ]
[ time 3 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 6 (of 10) ]
[ time 4 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 10) ]
[ time 5 ] JOB BEGINS by JOB 1
[ time 5 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 4 (of 5) ]
[ time 6 ] IO_START by JOB 1
IO DONE
[ time 6 ] JOB BEGINS by JOB 2
[ time 6 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 4 (of 5) ]
[ time 7 ] IO_START by JOB 2
IO DONE
[ time 7 ] IO_DONE by JOB 1
[ time 7 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 3 (of 5) ]
[ time 8 ] IO_START by JOB 1
IO DONE
[ time 8 ] IO_DONE by JOB 2
[ time 8 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 3 (of 5) ]
[ time 9 ] IO_START by JOB 2
IO DONE
[ time 9 ] IO_DONE by JOB 1
[ time 9 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 2 (of 5) ]
[ time 10 ] IO_START by JOB 1
IO DONE
[ time 10 ] IO_DONE by JOB 2
[ time 10 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 2 (of 5) ]
[ time 11 ] IO_START by JOB 2
IO DONE
[ time 11 ] IO_DONE by JOB 1
[ time 11 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 1 (of 5) ]
[ time 12 ] IO_START by JOB 1
IO DONE
[ time 12 ] IO_DONE by JOB 2
[ time 12 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 1 (of 5) ]
[ time 13 ] IO_START by JOB 2
IO DONE
[ time 13 ] IO_DONE by JOB 1
[ time 13 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 0 (of 5) ]
[ time 14 ] FINISHED JOB 1
[ time 14 ] IO_DONE by JOB 2
[ time 14 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 0 (of 5) ]
[ time 15 ] FINISHED JOB 2
[ time 15 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 10) ]
[ time 16 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 3 (of 10) ]
[ time 17 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 2 (of 10) ]
[ time 18 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 10) ]
[ time 19 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 10) ]
[ time 20 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  20
  Job  1: startTime   5 - response   0 - turnaround   9
  Job  2: startTime   6 - response   0 - turnaround   9

  Avg  2: startTime n/a - response 0.00 - turnaround 12.67
```

- 예 3에서 대화형 작업을 추가하였을 때, 짧은 대화형 작업이 CPU를 양도하면 더 낮은 우선순위 큐에 있는 작업이 실행될 수 있음을 알 수 있었다
- 하지만 대화형 작업이 매우 많은 경우에는 위와 같이 기아(starvation)가 발생활 수 있다
- CPU 위주의 긴 작업(JOB 0)이 실행되고 타임 슬라이스를 거쳐 PRIORITY 0으로 이동된다. 그 후 짧은 대화형 작업들(JOB 1, 2)이 1초 마다 1초 간격으로 I/O 작업을 실행하면 대화형 작업이 모두 끝날 때까지 JOB 0은 실행되지 못하는 기아 현상이 발생한다
- 여기서도 대화형 작업은 타임 슬라이스가 끝나기 전에 CPU를 양도하므로(io frequency < quantum) 우선순위 큐는 하락하지 않는다

```shell
$> python mlfq.py --jlist=0,10,0:5,5,1:6,5,1 --numQueues=3 --quantum=2 --stay --iotime=1 --boost=10 -c
Here is the list of inputs:
OPTIONS jobs 3
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   2
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   2
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   2
OPTIONS boost 10
OPTIONS ioTime 1
OPTIONS stayAfterIO True
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  10 - ioFreq   0
  Job  1: startTime   5 - runTime   5 - ioFreq   1
  Job  2: startTime   6 - runTime   5 - ioFreq   1


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 9 (of 10) ]
[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 8 (of 10) ]
[ time 2 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 7 (of 10) ]
[ time 3 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 6 (of 10) ]
[ time 4 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 10) ]
[ time 5 ] JOB BEGINS by JOB 1
[ time 5 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 4 (of 5) ]
[ time 6 ] IO_START by JOB 1
IO DONE
[ time 6 ] JOB BEGINS by JOB 2
[ time 6 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 4 (of 5) ]
[ time 7 ] IO_START by JOB 2
IO DONE
[ time 7 ] IO_DONE by JOB 1
[ time 7 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 3 (of 5) ]
[ time 8 ] IO_START by JOB 1
IO DONE
[ time 8 ] IO_DONE by JOB 2
[ time 8 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 3 (of 5) ]
[ time 9 ] IO_START by JOB 2
IO DONE
[ time 9 ] IO_DONE by JOB 1
[ time 9 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 2 (of 5) ]
[ time 10 ] IO_START by JOB 1
IO DONE
[ time 10 ] BOOST ( every 10 )
[ time 10 ] IO_DONE by JOB 2
[ time 10 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 4 (of 10) ]
[ time 11 ] IO_DONE by JOB 1
[ time 11 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 3 (of 10) ]
[ time 12 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 2 (of 5) ]
[ time 13 ] IO_START by JOB 2
IO DONE
[ time 13 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 1 (of 5) ]
[ time 14 ] IO_START by JOB 1
IO DONE
[ time 14 ] IO_DONE by JOB 2
[ time 14 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 1 (of 5) ]
[ time 15 ] IO_START by JOB 2
IO DONE
[ time 15 ] IO_DONE by JOB 1
[ time 15 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 0 (of 5) ]
[ time 16 ] FINISHED JOB 1
[ time 16 ] IO_DONE by JOB 2
[ time 16 ] Run JOB 2 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 0 (of 5) ]
[ time 17 ] FINISHED JOB 2
[ time 17 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 2 (of 10) ]
[ time 18 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 1 (of 10) ]
[ time 19 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 0 (of 10) ]
[ time 20 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  20
  Job  1: startTime   5 - response   0 - turnaround  11
  Job  2: startTime   6 - response   0 - turnaround  11

  Avg  2: startTime n/a - response 0.00 - turnaround 14.00
```

- 기아 상태를 방지하기 위해 일정 시간마다 상향 조정(boost)를 실시한다 : `--boost=10`
- 바로 위의 예제에서 모든 대화형 작업이 끝날 때까지 실행되지 않던 CPU 위주 작업(JOB 0)이 boost에 의해 PRIORITY 2로 상향되면서 대화형 작업과 같이 실행된다

##### 예 5: 조작에 대한 내성 방지

!["8-6"](8-6.png)

```shell
$> python mlfq.py --jlist=0,20,0:10,20,3 --numQueues=3 --quantum=4 --stay --iotime=1 -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   4
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   4
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   4
OPTIONS boost 0
OPTIONS ioTime 1
OPTIONS stayAfterIO True
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  20 - ioFreq   0
  Job  1: startTime  10 - runTime  20 - ioFreq   3


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 2 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 3 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 4 ] Run JOB 0 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 5 ] Run JOB 0 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 6 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 7 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 8 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 9 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 10 ] JOB BEGINS by JOB 1
[ time 10 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 11 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 12 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 13 ] IO_START by JOB 1
IO DONE
[ time 13 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 14 ] IO_DONE by JOB 1
[ time 14 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 16 (of 20) ]
[ time 15 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 15 (of 20) ]
[ time 16 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 14 (of 20) ]
[ time 17 ] IO_START by JOB 1
IO DONE
[ time 17 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 18 ] IO_DONE by JOB 1
[ time 18 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 13 (of 20) ]
[ time 19 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 12 (of 20) ]
[ time 20 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 11 (of 20) ]
[ time 21 ] IO_START by JOB 1
IO DONE
[ time 21 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 22 ] IO_DONE by JOB 1
[ time 22 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 10 (of 20) ]
[ time 23 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 9 (of 20) ]
[ time 24 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 8 (of 20) ]
[ time 25 ] IO_START by JOB 1
IO DONE
[ time 25 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 26 ] IO_DONE by JOB 1
[ time 26 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 27 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 28 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 29 ] IO_START by JOB 1
IO DONE
[ time 29 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 30 ] IO_DONE by JOB 1
[ time 30 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 4 (of 20) ]
[ time 31 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 3 (of 20) ]
[ time 32 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 2 (of 20) ]
[ time 33 ] IO_START by JOB 1
IO DONE
[ time 33 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 34 ] IO_DONE by JOB 1
[ time 34 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 1 (of 20) ]
[ time 35 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 0 (of 20) ]
[ time 36 ] FINISHED JOB 1
[ time 36 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 37 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 38 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 39 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 40 ] FINISHED JOB 0

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  40
  Job  1: startTime  10 - response   0 - turnaround  26

  Avg  1: startTime n/a - response 0.00 - turnaround 33.00
```

- 워크로드가 스케줄러를 자신에게 유리하게 동작시키려고 할 때 예전 규칙 4a와 4b일 때의 행동이다.
- 즉, 주어진 타임 슬라이스를 모두 사용하지 않으면서(3초 간격으로 I/O 작업 실행, 우선순위 큐 유지) I/O 작업을 최대한 짧게 가져가면(`--iotime=1`), CPU를 사실상 독점할 수 있다
- 특정 워크로드가 주어진 타임 슬라이스(4)에서 I/O 작업을 실행하는 주기(3) + I/O 작업 시간(1)이 4를 넘지 않으므로 우선순위 큐는 유지된다
- I/O 작업 시간 동안은 다른 CPU를 양도하여 다른 프로세스가 실행될 수 있다. 하지만 그 시간이 매우 짧으므로 나머지 시간은 해당 워크로드가 사용한다
- 지금은 4:3 비율이지만, 타임 슬라이스가 더 커지고 I/O 작업 시간은 1로 고정되어 있다면(e.g. 10:1) 독점 비율은 더 늘어나게 된다

```shell
$> python mlfq.py --jlist=0,20,0:10,20,3 --numQueues=3 --quantum=4 --iotime=1 -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   4
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   4
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   4
OPTIONS boost 0
OPTIONS ioTime 1
OPTIONS stayAfterIO False
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  20 - ioFreq   0
  Job  1: startTime  10 - runTime  20 - ioFreq   3


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 2 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 3 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 4 ] Run JOB 0 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 5 ] Run JOB 0 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 6 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 7 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 8 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 9 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 10 ] JOB BEGINS by JOB 1
[ time 10 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 11 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 12 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 13 ] IO_START by JOB 1
IO DONE
[ time 13 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 14 ] IO_DONE by JOB 1
[ time 14 ] Run JOB 1 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 15 ] Run JOB 1 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 16 ] Run JOB 1 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 17 ] IO_START by JOB 1
IO DONE
[ time 17 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 18 ] IO_DONE by JOB 1
[ time 18 ] Run JOB 1 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 19 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 20 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 21 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 22 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 23 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 24 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 25 ] IO_START by JOB 1
IO DONE
[ time 25 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 26 ] IO_DONE by JOB 1
[ time 26 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 27 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 28 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 29 ] FINISHED JOB 0
[ time 29 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 30 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 31 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 32 ] IO_START by JOB 1
IO DONE
[ time 32 ] IDLE
[ time 33 ] IO_DONE by JOB 1
[ time 33 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 34 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 35 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 36 ] IO_START by JOB 1
IO DONE
[ time 36 ] IDLE
[ time 37 ] IO_DONE by JOB 1
[ time 37 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 38 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 39 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 40 ] IO_START by JOB 1
IO DONE
[ time 40 ] IDLE
[ time 41 ] IO_DONE by JOB 1
[ time 41 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 42 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 43 ] FINISHED JOB 1

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  29
  Job  1: startTime  10 - response   0 - turnaround  33

  Avg  1: startTime n/a - response 0.00 - turnaround 31.00
```

- I/O 작업을 할 때마다 우선순위 큐를 유지하고 시간 할당을 초기화하는 `--stay` 옵션 제거
- 짧은 대화형 작업(JOB 1)이 처음 추가되었을 초기에는 이전 예제와 독점 양상을 보이지만, 시간이 지나고 시간 할당량을 다 소진한다면 우선순위가 하락한다
- 대화형 작업이 PRIORITY 0까지 하락한다면(time 19), RR을 이용하여 같은 비율로 실행된다

#### 3. 라운드 로빈 스케줄러처럼 동작시키려면 스케줄러의 매개변수를 어떻게 설정해야 하는가?

```shell
$> python mlfq.py --jlist=0,10,0:5,2,0 --numQueues=1 --quantum=1 -c
```

- 하나의 큐(`--numQueues=1`)와 타임 슬라이스를 줘서(`--quantum=1`) 작업이 번갈아가며 실행되도록 한다

#### 4. 두 개의 작업과 스케줄러 매개변수를 가진 워크로드를 고안하시오. 두 작업 중 하나의 작업은 옛날 규칙 4a 및 4b를 이용하여 (-S 플래그를 켠다) 스케줄러를 자신에게 유리하게 동작하도록 만들어 특정 구간에서 99%의 CPU를 차지하도록 고안해야 한다.

```shell
$> python mlfq.py --jlist=0,500,0:200,500,99 --numQueues=2 --quantum=100 --stay --iotime=1 -c
```

- 100의 타임 슬라이스 중에 99만큼은 CPU를 사용하고 1동안 I/O 작업을 실행한다
- `--stay` 옵션을 주어 타임 슬라이스를 소진하지 않는 경우 우선순위 큐 유지 및 시간 할당 초기화를 한다.

#### 5. 가장 높은 우선순위 큐의 타임 퀀텀의 길이가 10 ms인 시스템이 있다고 하자. 하나의 장기 실행(및 잠재적인 기아 위험) 작업이 적어도 5%의 CPU를 사용할 수 있도록 보장하려면 얼마나 자주 가장 높은 우선순위로 이동시켜야 하는가(-B 플래그 켠다)?

- 200ms
- 한 번 가장 높은 우선순위로 올라갔을 때 10ms만큼 CPU를 사용할 수 있다. 10ms / x = 5 / 100, x = 200ms이다

#### 6. 스케줄링에서 제기되는 질문 중 하나는, 입출력이 방금 종료된 작업은 큐의 어느 쪽에 추가해야 하는가이다. 플래그 -I가 시뮬레이터의 이 행동 양식을 변경한다. 몇 개의 워크로드를 가지고 실험하여 이 플래그의 영향을 확인할 수 있는지 보라.

```shell
$> python mlfq.py --jlist=0,20,0:10,20,3 --numQueues=3 --quantum=4 --iotime=1 -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   4
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   4
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   4
OPTIONS boost 0
OPTIONS ioTime 1
OPTIONS stayAfterIO False
OPTIONS iobump False


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  20 - ioFreq   0
  Job  1: startTime  10 - runTime  20 - ioFreq   3


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 2 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 3 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 4 ] Run JOB 0 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 5 ] Run JOB 0 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 6 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 7 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 8 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 9 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 10 ] JOB BEGINS by JOB 1
[ time 10 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 11 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 12 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 13 ] IO_START by JOB 1
IO DONE
[ time 13 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 14 ] IO_DONE by JOB 1
[ time 14 ] Run JOB 1 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 15 ] Run JOB 1 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 16 ] Run JOB 1 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 17 ] IO_START by JOB 1
IO DONE
[ time 17 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 18 ] IO_DONE by JOB 1
[ time 18 ] Run JOB 1 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 19 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 20 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 21 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 22 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 23 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 24 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 25 ] IO_START by JOB 1
IO DONE
[ time 25 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 26 ] IO_DONE by JOB 1
[ time 26 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 27 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 28 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 29 ] FINISHED JOB 0
[ time 29 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 30 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 31 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 32 ] IO_START by JOB 1
IO DONE
[ time 32 ] IDLE
[ time 33 ] IO_DONE by JOB 1
[ time 33 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 34 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 35 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 36 ] IO_START by JOB 1
IO DONE
[ time 36 ] IDLE
[ time 37 ] IO_DONE by JOB 1
[ time 37 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 38 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 39 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 40 ] IO_START by JOB 1
IO DONE
[ time 40 ] IDLE
[ time 41 ] IO_DONE by JOB 1
[ time 41 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 42 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 43 ] FINISHED JOB 1

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  29
  Job  1: startTime  10 - response   0 - turnaround  33

  Avg  1: startTime n/a - response 0.00 - turnaround 31.00
```

```shell
$> python mlfq.py --jlist=0,20,0:10,20,3 --numQueues=3 --quantum=4 --iotime=1 -I -c
Here is the list of inputs:
OPTIONS jobs 2
OPTIONS queues 3
OPTIONS allotments for queue  2 is   1
OPTIONS quantum length for queue  2 is   4
OPTIONS allotments for queue  1 is   1
OPTIONS quantum length for queue  1 is   4
OPTIONS allotments for queue  0 is   1
OPTIONS quantum length for queue  0 is   4
OPTIONS boost 0
OPTIONS ioTime 1
OPTIONS stayAfterIO False
OPTIONS iobump True


For each job, three defining characteristics are given:
  startTime : at what time does the job enter the system
  runTime   : the total CPU time needed by the job to finish
  ioFreq    : every ioFreq time units, the job issues an I/O
              (the I/O takes ioTime units to complete)

Job List:
  Job  0: startTime   0 - runTime  20 - ioFreq   0
  Job  1: startTime  10 - runTime  20 - ioFreq   3


Execution Trace:

[ time 0 ] JOB BEGINS by JOB 0
[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 2 ] Run JOB 0 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 3 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 4 ] Run JOB 0 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 5 ] Run JOB 0 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 6 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 7 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 8 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 9 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 10 ] JOB BEGINS by JOB 1
[ time 10 ] Run JOB 1 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 19 (of 20) ]
[ time 11 ] Run JOB 1 at PRIORITY 2 [ TICKS 2 ALLOT 1 TIME 18 (of 20) ]
[ time 12 ] Run JOB 1 at PRIORITY 2 [ TICKS 1 ALLOT 1 TIME 17 (of 20) ]
[ time 13 ] IO_START by JOB 1
IO DONE
[ time 13 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 14 ] IO_DONE by JOB 1
[ time 14 ] Run JOB 1 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 16 (of 20) ]
[ time 15 ] Run JOB 1 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 15 (of 20) ]
[ time 16 ] Run JOB 1 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 14 (of 20) ]
[ time 17 ] IO_START by JOB 1
IO DONE
[ time 17 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 18 ] IO_DONE by JOB 1
[ time 18 ] Run JOB 1 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 13 (of 20) ]
[ time 19 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 12 (of 20) ]
[ time 20 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 21 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 22 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 23 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 24 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 11 (of 20) ]
[ time 25 ] IO_START by JOB 1
IO DONE
[ time 25 ] Run JOB 0 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 26 ] IO_DONE by JOB 1
[ time 26 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 10 (of 20) ]
[ time 27 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 9 (of 20) ]
[ time 28 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 8 (of 20) ]
[ time 29 ] IO_START by JOB 1
IO DONE
[ time 29 ] Run JOB 0 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 30 ] IO_DONE by JOB 1
[ time 30 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 7 (of 20) ]
[ time 31 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 6 (of 20) ]
[ time 32 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 5 (of 20) ]
[ time 33 ] IO_START by JOB 1
IO DONE
[ time 33 ] Run JOB 0 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 34 ] IO_DONE by JOB 1
[ time 34 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 4 (of 20) ]
[ time 35 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 36 ] FINISHED JOB 0
[ time 36 ] Run JOB 1 at PRIORITY 0 [ TICKS 3 ALLOT 1 TIME 3 (of 20) ]
[ time 37 ] Run JOB 1 at PRIORITY 0 [ TICKS 2 ALLOT 1 TIME 2 (of 20) ]
[ time 38 ] IO_START by JOB 1
IO DONE
[ time 38 ] IDLE
[ time 39 ] IO_DONE by JOB 1
[ time 39 ] Run JOB 1 at PRIORITY 0 [ TICKS 1 ALLOT 1 TIME 1 (of 20) ]
[ time 40 ] Run JOB 1 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ]
[ time 41 ] FINISHED JOB 1

Final statistics:
  Job  0: startTime   0 - response   0 - turnaround  36
  Job  1: startTime  10 - response   0 - turnaround  31

  Avg  1: startTime n/a - response 0.00 - turnaround 33.50
```

- I 플래그는 같은 우선순위 큐에 여러 워크로드가 RR로 동시에 실행되고 있을 때, I/O 작업이 끝난 특정 워크로드가 실행 중인 다른 워크로드보다 먼저 실행될 수 있도록 한다
- I 플래그가 없다면, I/O 작업이 끝난 특정 워크로드는 우선순위 큐 뒤에 추가되어 **현재 RR로 실행 중인 워크로드가 끝난 이후에 실행된다.** 반면, I 플래그가 있다면 I/O 작업이 끝난 특정 워크로드는 우선순위 큐 맨 앞에 추가되어 **현재 RR로 실행 중인 워크로드를 중단하고 먼저 실행된다.**
- 위의 실행 결과에서는 time 26에 차이가 발생한다. I 플래그가 없으면 현재 실행 중인 JOB 0이 끝나는 time 29에 JOB 1이 실행되지만, I 플래그가 있으면 현재 실행 중인 JOB 0의 주어진 time quantum이 끝나기 전인 time 26에 JOB 1을 실행한다. 그 후 I/O 작업이 시작되는 time 29에 JOB 0을 실행하게 된다
- 이런 방식으로 I/O 작업 워크로드를 먼저 실행함으로써 IDLE 시간을 43 -> 41로 줄일 수 있다. 단, 문맥 교환은 9 -> 15로 증가한다
- 실행할 워크로드가 같은 우선순위 큐에 있지 않으면 크게 의미가 없는 플래그이다

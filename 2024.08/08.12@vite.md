## vite

- create-react-app의 대체재라고 생각하면 될 듯?
- script, lint, typescript, 트랜스파일러, 기본적인 뼈대 등 초기 세팅을 해주는 역할
- cra와 vite의 아키텍처는 어떻게 다른가?

```shell
npm create vite@latest
```

### vite 개발 서버에서 webpack 번들링이 없는 이유?

- vite 개발 서버에서 브라우저가 지원하는 네이티브 ESM(ECMAScript Modules)을 활용하여 모듈을 로드
  - `<script type="module">` 태그를 사용하면 브라우저가 ESM을 실행할 수 있는 것을 이용하여, vite 개발 서버는 네이티브 ESM을 사용하여 소스 코드를 그대로 브라우저에 제공
  - 브라우저는 vite로부터 개별 모듈을 요청, vite는 ESM 형식으로 코드를 제공하여 브라우저가 바로 이해하고 실행할 수 있도록 함 => 즉, 번들링하는 과정을 제거하여 속도를 높임
  - 개발 과정에서는 번들링하지 않고, 프로덕션 빌드에서만 전체 번들링(ESBuild, Rollup)을 수행
- 1. 번들링
  - webpack은 왜 번들링하는 과정이 필요한가?
    - (1) webpack을 사용하면, 입력 js 파일을 CJS(CommonJS) 모듈로 변환하고 이를 의존성 트리 구조로 계층화함
    - 입력은 ESM, CJS, AMD 등 다양한 파일을 받을 수 있지만, 모든 파일은 CJS 형식으로 변환됨
    - (2) 내부적으로 트리 구조로 변환 및 모듈 간의 의존성을 분석: 다른 모듈과 어떻게 연결되어 있는지? 어떤 순서로 로드해야 하는지? 등...
    - (3) 최적화 수행: 트리 쉐이킹(사용되지 않는 코드 제거)
    - (4) 의존성 트리를 기반으로 브라우저에서 동작할 수 있는 번들 파일을 생성
- 2. Hot Module Replacement(HMR)
  - webpack: 파일이 변경되면 새로운 번들을 생성(js 파일 입력 => 의존성 트리 => 최적화 => 번들 파일 출력)하여 수정된 부분만 브라우저에게 전달
  - vite: 파일이 변경되면 개발 서버가 이를 감지하고 브라우저와 연결된 웹소켓을 통해 특정 모듈이 변경되었음을 전달 => 브라우저는 변경된 모듈을 개발 서버로 재요청 => 개발 서버가 수정된 모듈을 응답 => 브라우저는 해당 모듈만 갱신
- 3. 트랜스파일링: Typescript, JSX를 변환
  - webpack: 모든 모듈(파일)에 대해 트랜스파일링 수행
  - vite: 브라우저가 요청하는 파일만 대상으로 트랜스파일링 수행
- 결과적으로 vite는 **ESM을 서버 측에서도 활용하여** 개발 과정에서 번들링 과정을 제거하여 빠른 속도로 개발 경험을 최적화하는데 큰 의미가 있음

### SWC

- babel(트랜스파일러)의 대체재
- Rust로 만들었고, 최적화 측면에서 babel보다 빠르고 좋다고 할 수 있다
- babel의 단점을 아직 못 느껴봐서 큰 감흥은 없다
- (왜 SWC를 사용해야 하는가?) https://velog.io/@kwonhygge/Next-JS%EA%B0%80-Babel%EC%9D%84-SWC%EB%A1%9C-%EB%8C%80%EC%B2%B4%ED%95%9C-%EC%9D%B4%EC%9C%A0
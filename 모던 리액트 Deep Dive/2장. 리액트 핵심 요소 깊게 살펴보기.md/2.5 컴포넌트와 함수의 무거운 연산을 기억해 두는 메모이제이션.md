# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- 리액트에서 제공하는 훅 `useMemo`, `useCallback`과 고차 컴포넌트 `memo`는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해 제공된다.
- 이러한 메모이제이션 기법은 언제 사용하는 것이 좋을까?
- 전제는 "일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다"이다.

## 주장 1: 필요한 곳에만 메모이제이션을 추가하자

- 메모이제이션에도 비용이 발생한다.
- (1) 값을 비교하고 재계산이 필요한지 확인하는 비용 (2) 결과물을 저장하는 비용 + 다시 찾아오는 비용
- 상황에 따라 이 비용이 리렌더링 비용보다 클 수 있음에 유의해야 한다.
- 미리 모든 부분(또는 많이 리렌더링이 일어날 것이라고 예측되는 부분)에서 메모이제이션을 해두는 것이 아니라, 애플리케이션을 만든 이후에 개발자 도구나 `useEffect`를 사용해 어떻게 렌더링이 일어나는지 확인하고 필요한 곳에서만 최적화를 하는 것이 옳다.
- 다시 말해서 memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법이다.

## 주장 2: 렌더링 과정의 비용은 비싸기 때문에 가능한 한 많이 메모이제이션을 하자

- memo를 일단 그냥 다 적용하는 방법이다.
- 렌더링 비용이 작은 컴포넌트에 memo를 적용했을 때의 비용? props에 대한 얕은 비교에 대한 비용이다.
- 재조정 과정에서 이미 결과물을 저장하고 있기 때문에 memo를 사용함에 있어 추가적으로 메모리를 사용하지는 않는다.
- 따라서 메모이제이션을 통해 지불해야 하는 비용은 props에 대한 얕은 비교에 대한 비용뿐이라고 할 수 있다.
- props가 크고 복잡해진다면 이 비용 또한 커질 수 있다.
- 메모이제이션을 하지 않았을 때의 비용은 더 크다는 것은 대부분 알고 있을 것이다.

[](./useMath/useMath.tsx)

## 결론

- 모두 메모이제이션을 했을 떄의 이점이 하지 않았을 때의 이점보다 더 크다.
- 최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.
- 최적화를 위해 투자할 시간이 있다면 필요한 곳에만 메모이제이션을 해보자.

## 추가

- 재조정 과정에서 `useMemo`, `useCallback`의 참조가 바뀌었는지 확인하는 시점은 컴포넌트 함수를 호출한 이후이다. 즉, 해당 값 또는 컴포넌트가 렌더링 대상이라는 뜻이다. 호출 후에 참조가 변하지 않았다면 렌더링 대상이 되지 않고, 변했다면 렌더링 대상이 된다.

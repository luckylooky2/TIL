## 1. 개념

- 핫 리로딩: 코드 변경 사항을 실시간으로 반영하면서 애플리케이션의 상태를 유지하는 기술
- 기존 애플리케이션을 중단하지 않고, 변경된 부분만 런타임에 주입하여 반영
- 핫 리로딩이 발생하면
	- 함수 컴포넌트는 상태 값을 건드리지 않는 한 상태 값이 유지된다.
	- 클래스 컴포넌트는 언제나 상태 값이 초기화된다.

## 2. 함수 컴포넌트와 클래스 컴포넌트 간의 차이가 발생하는 이유?

- 핫 리로딩 과정에서 발생하는 것인가?
- 아니면 리액트와 관련이 있는 것인가?
- 아니면 자바스크립트와 관련이 있는 것인가?

- 클래스 컴포넌트는 핫 리로딩 시 **새로운 클래스 정의**가 자바스크립트 엔진에 의해 인식되면, 리액트는 기존 클래스 컴포넌트 인스턴스를 **재정의된 클래스**에 맞춰 새로 만들어야 한다.
	-  **클래스 정의**: 클래스를 정의할 때, 이는 자바스크립트의 메모리 상에 **새로운 객체**로 저장된다.
	- 핫 리로딩 과정에서 클래스 정의가 바뀌면, 자바스크립트는 이를 **새로운 클래스로 인식**한다.
	- 새롭게 정의된 클래스는 **이전 클래스와 다르다고 간주**되며, 이전에 생성된 인스턴스들은 이 새 정의와 일치하지 않기 때문에 **무효화**된다.
	- 결과적으로 **기존 인스턴스가 사라지고**, 새로 정의된 클래스에 맞춰 **새 인스턴스가 생성**된다. 이로 인해 클래스의 상태가 **초기화**된다.
- 함수 컴포넌트는 함수가 다시 호출되더라도 리액트는 상태를 훅 시스템을 통해 유지하고, 함수 정의 자체는 상태를 직접적으로 관리하지 않기 때문에 핫 리로딩 시에도 상태를 유지할 수 있다.
	- 반면에 **함수형 컴포넌트**는 **단순한 함수**로 정의되며, 리액트의 상태 관리 시스템(훅)을 통해 상태를 별도로 관리한다.
	- 핫 리로딩 시 함수가 다시 호출되더라도, 리액트는 **함수의 상태**를 외부에서 관리하고 있기 때문에 상태값을 유지할 수 있다.
	- 함수형 컴포넌트는 재정의되더라도, 함수 호출 시 내부 상태(useState, useReducer)가 리액트에 의해 별도로 관리되므로, 상태를 유지할 수 있다.

## 3. 문제점

```jsx
function FunctionalComponent() {
  const [count, setCount] = React.useState(0);

  function handleClick() {
    setCount((prev) => prev + 1);
  }

  return (
    <>
      <button onClick={handleClick}>{count} + </button>
    </>
  );
}

class ClassComponent extends React.Component {
  private constructor(props) {
    super(props);

    this.state = {
      count: 0,
    };
  }

  private handleClick = () => {
    this.setState((prev) => ({ count: prev.count + 1 }));
  };

  public render() {
    return <button onClick={this.handleClick}>{this.state.count} + </button>;
  }
}

function App() {
  return (
    <>
      <FunctionalComponent />
      <ClassComponent />
    </>
  );
}
```

- FunctionalComponent 위에 값을 추가할 때, 함수 컴포넌트의 상태 값도 초기화되었다.
- 컴포넌트 트리의 구조가 변경되면 핫 리로딩 도구는 이 변경을 “새로운 컴포넌트”로 인식한다.
- 빌드 대상이 달라지기 때문에 컴포넌트 자체를 새로 생성하게 되고, 함수 컴포넌트의 상태(useState로 관리되는 상태)가 초기화되었다.